{"version":3,"file":"static/js/2079.456be601.chunk.js","mappings":"kLAIgB,SAAAA,EACdC,EACAC,EACAC,GAOI,IACAC,EADAC,EAAOF,EAAKG,aAAe,GAG/B,MAAO,KAbO,IAAAC,EAAAC,EAAAC,EAAAC,EAcR,IAAAC,EACAR,EAAKS,MAAO,OAAAL,EAAAJ,EAAKU,YAAL,EAAAN,EAAAO,KAAAX,MAAgBQ,EAAUI,KAAKC,OAE/C,MAAMC,EAAUhB,IAMhB,KAHEgB,EAAQC,SAAWb,EAAKa,QACxBD,EAAQE,MAAK,CAACC,EAAUC,IAAkBhB,EAAKgB,KAAWD,KAGnD,OAAAhB,EAKL,IAAAkB,EAKJ,GAPOjB,EAAAY,EAGHd,EAAKS,MAAO,OAAAJ,EAAAL,EAAKU,YAAL,EAAAL,EAAAM,KAAAX,MAAgBmB,EAAaP,KAAKC,OAEzCZ,EAAAF,KAAMe,GAEXd,EAAKS,MAAO,OAAAH,EAAAN,EAAKU,YAAL,EAAAJ,EAAAK,KAAAX,IAAgB,CACxB,MAAAoB,EAAaC,KAAKC,MAAgC,KAAzBV,KAAKC,MAAQL,IAAmB,IACzDe,EAAgBF,KAAKC,MAAmC,KAA5BV,KAAKC,MAAQM,IAAsB,IAC/DK,EAAsBD,EAAgB,GAEtCE,EAAMA,CAACC,EAAsBC,KAE1B,IADPD,EAAME,OAAOF,GACNA,EAAIX,OAASY,GAClBD,EAAM,IAAMA,EAEP,OAAAA,CAAA,EAGDG,QAAAC,KACN,YAAOL,EAAIF,EAAe,OAAOE,EAAIL,EAAY,QACjD,2FAGiBC,KAAKU,IAChB,EACAV,KAAKW,IAAI,IAAM,IAAMR,EAAqB,sBAEhD,MAAAxB,OAAA,EAAAA,EAAMS,IAEV,CAIO,OAFP,OAAAF,EAAA,MAAAP,OAAA,EAAAA,EAAMiC,WAAN1B,EAAAI,KAAAX,EAAiBC,GAEVA,CAAA,CAEX,CAEgB,SAAAiC,EAAgBC,EAAsBC,GACpD,QAAc,IAAVD,EACI,UAAIE,MAAM,wBAAuBD,EAAM,KAAKA,IAAQ,KAEnD,OAAAD,CAEX,CAEa,MAEAG,EAAWA,CACtBC,EACAxC,EACAyC,KAEI,IAAAC,EACJ,OAAO,YAAwBC,GAC7BH,EAAaI,aAAaF,GACdA,EAAAF,EAAaK,YAAW,IAAM7C,EAAG8C,MAAMC,KAAMJ,IAAOF,EAAE,GCzCzDO,EAAuB7B,GAAkBA,EAEzC8B,EAAyBC,IACpC,MAAMC,EAAQ7B,KAAKU,IAAIkB,EAAME,WAAaF,EAAMG,SAAU,GACpDC,EAAMhC,KAAKW,IAAIiB,EAAMK,SAAWL,EAAMG,SAAUH,EAAMM,MAAQ,GAE9DC,EAAM,GAEZ,IAAK,IAAIC,EAAIP,EAAOO,GAAKJ,EAAKI,IAC5BD,EAAIE,KAAKD,GAGJ,OAAAD,CAAA,EAGIG,EAAqBA,CAChCC,EACAC,KAEA,MAAMC,EAAUF,EAASG,cACzB,IAAKD,EACH,OAEF,MAAMvB,EAAeqB,EAASrB,aAC9B,IAAKA,EACH,OAGI,MAAAyB,EAAWC,IACT,YAAEC,EAAA,OAAOC,GAAWF,EACvBJ,EAAA,CAAEK,MAAO7C,KAAKC,MAAM4C,GAAQC,OAAQ9C,KAAKC,MAAM6C,IAAS,EAKzD,GAFIH,EAAAF,EAAQM,0BAEX7B,EAAa8B,eAChB,MAAO,OAGT,MAAMC,EAAW,IAAI/B,EAAa8B,gBAAgBE,IAC1C,MAAAC,EAAQD,EAAQ,GACtB,GAAI,MAAAC,OAAA,EAAAA,EAAOC,cAAe,CAClB,MAAAC,EAAMF,EAAMC,cAAc,GAChC,GAAIC,EAEF,YADAV,EAAQ,CAAEE,MAAOQ,EAAIC,WAAYR,OAAQO,EAAIE,WAGjD,CACQZ,EAAAF,EAAQM,wBAAwB,IAK1C,OAFAE,EAASO,QAAQf,EAAS,CAAEY,IAAK,eAE1B,KACLJ,EAASQ,UAAUhB,EAAQ,CAAD,EAIxBiB,EAA0B,CAC9BC,SAAS,GAwBLC,EACa,oBAAVC,QAA+B,gBAAiBA,OAE5CC,EAAuBA,CAClCvB,EACAC,KAEA,MAAMC,EAAUF,EAASG,cACzB,IAAKD,EACH,OAEF,MAAMvB,EAAeqB,EAASrB,aAC9B,IAAKA,EACH,OAGF,IAAI6C,EAAS,EACP,MAAAC,EAAWJ,EACb,KAAM,EACN3C,EACEC,GACA,KACEsB,EAAGuB,GAAQ,EAAM,GAEnBxB,EAAS0B,QAAQC,uBAGjBC,EAAiBC,GAAyB,KAC9CL,EAAStB,EAAQF,EAAS0B,QAAQI,WAAa,aAAe,aACrDL,IACTxB,EAAGuB,EAAQK,EAAY,EAEnBzB,EAAUwB,GAAc,GACxBG,EAAaH,GAAc,GAMjC,OALWG,IAEH7B,EAAA8B,iBAAiB,SAAU5B,EAASe,GACpCjB,EAAA8B,iBAAiB,YAAaD,EAAYZ,GAE3C,KACGjB,EAAA+B,oBAAoB,SAAU7B,GAC9BF,EAAA+B,oBAAoB,YAAaF,EAAW,CAAD,EA8C1CG,EAAiBA,CAC5BhC,EACAU,EACAZ,KAEA,GAAI,MAAAY,OAAA,EAAAA,EAAOC,cAAe,CAClB,MAAAC,EAAMF,EAAMC,cAAc,GAChC,GAAIC,EAAK,CAIA,OAHMrD,KAAKC,MAChBoD,EAAId,EAAS0B,QAAQI,WAAa,aAAe,aAGrD,CACF,CACA,OAAOrE,KAAKC,MACVwC,EAAQM,wBACNR,EAAS0B,QAAQI,WAAa,QAAU,UAC1C,EAoBSK,EAAgBA,CAC3BX,GAEEY,cAAc,EACdC,YAEFrC,K,QAEA,MAAMsC,EAAWd,EAASY,EAE1B,OAAA3F,EAAA,OAAAD,EAAAwD,EAASG,oBAAT,EAAA3D,EAAwB+F,WAAxB9F,EAAAM,KAAAP,EAAmC,CACjC,CAACwD,EAAS0B,QAAQI,WAAa,OAAS,OAAQQ,EAChDD,YAAA,EA0DG,MAAMG,EAqDXC,WAAAA,CAAYrG,GAjDZ,KAAQsG,OAAqC,GAEN,KAAAvC,cAAA,KACa,KAAAxB,aAAA,KACtC,KAAAkD,aAAA,EACd,KAAQc,uBAAwC,KAChD,KAAAC,kBAAsD,GAC9C,KAAAC,cAAA,IAAoBC,IAC5B,KAAQC,4BAA6C,GAC3B,KAAAC,WAAA,KACI,KAAAC,aAAA,KACY,KAAAC,gBAAA,KAC1C,KAAQC,kBAAoB,EAQ5B,KAAAC,cAAA,IAAoBN,IACpB,KAAQpC,SAAkB,MACxB,IAAI2C,EAA6B,KAEjC,MAAMC,EAAMA,IACND,IAICnE,KAAKP,cAAiBO,KAAKP,aAAa8B,eAIrC4C,EAAM,IAAInE,KAAKP,aAAa8B,gBAAgBE,IAC1CA,EAAA4C,SAAS3C,IACV,KAAA4C,gBAAgB5C,EAAM6C,OAAwB7C,EAAM,GACzD,IANK,MAUJ,OACL8C,WAAYA,K,MAAM,cAAAlH,EAAA8G,UAAA,EAAA9G,EAAOkH,YAAA,EACzBzC,QAAUwC,I,MACR,cAAAjH,EAAA8G,UAAA,EAAA9G,EAAOyE,QAAQwC,EAAQ,CAAE3C,IAAK,gBAChCI,UAAYuC,I,MAAoB,cAAAjH,EAAA8G,UAAA,EAAA9G,EAAO0E,UAAUuC,EAAA,EAClD,EAxBuB,GA0B+B,KAAApE,MAAA,KAMzD,KAAAsE,WAAcC,IACLC,OAAAlD,QAAQiD,GAAML,SAAQ,EAAE1G,EAAK0B,MACb,qBAAVA,UAA+BqF,EAAa/G,EAAI,IAG7DqC,KAAKwC,QAAU,CACb5E,OAAO,EACPgH,cAAe,EACftE,SAAU,EACVuE,aAAc,EACdC,WAAY,EACZC,mBAAoB,EACpBC,iBAAkB,EAClBpC,YAAY,EACZqC,WAAYhF,EACZiF,eAAgBhF,EAChBf,SAAUA,OACV6D,iBACAmC,YAAa,CAAE/D,MAAO,EAAGC,OAAQ,GACjC+D,aAAc,EACdC,IAAK,EACLC,eAAgB,aAChBC,yBAA0B,GAC1BC,MAAO,EACP/C,sBAAuB,IACvBgD,SAAS,KACNf,EAAA,EAIC,KAAAgB,OAAS,CAACC,EAAgBC,K,QAChC,MAAM,WAAEvF,EAAA,SAAYG,GAAaR,KAAKG,OAAS,CAC7CE,gBAAY,EACZG,cAAU,GAENL,EAAQH,KAAK6F,kBAGjBF,GACAtF,KAAe,MAAAF,OAAA,EAAAA,EAAOE,aACtBG,KAAa,MAAAL,OAAA,EAAAA,EAAOK,aAEf,OAAAjD,GAAAD,EAAA,KAAAkF,SAAQrD,WAAR5B,EAAAM,KAAAP,EAAmB0C,KAAM4F,GAChC,EAGF,KAAQE,QAAU,KACX,KAAAtC,OAAOuC,OAAOC,SAAS3B,SAAS4B,GAAMA,MAC3CjG,KAAKwD,OAAS,GACdxD,KAAKiB,cAAgB,KACrBjB,KAAKP,aAAe,KACpBO,KAAKwB,SAASgD,aACdxE,KAAKkE,cAAcgC,OAAA,EAGrB,KAAAC,UAAY,IACH,KACLnG,KAAK8F,SAAS,EAIlB,KAAAM,YAAc,K,MACZ,MAAMnF,EAAgBjB,KAAKwC,QAAQiD,QAC/BzF,KAAKwC,QAAQ6D,mBACb,KAEA,GAAArG,KAAKiB,gBAAkBA,EAAe,CAGxC,GAFAjB,KAAK8F,WAEA7E,EAEH,YADK,KAAAyE,QAAO,GAAO,GAIrB1F,KAAKiB,cAAgBA,EAEjBjB,KAAKiB,eAAiB,kBAAmBjB,KAAKiB,cAC3C,KAAAxB,aAAeO,KAAKiB,cAAcqF,cAAcC,YAEhD,KAAA9G,cAAe,OAAAnC,EAAA0C,KAAKiB,oBAAL,EAAA3D,EAAoB8E,SAAU,KAG/C,KAAAoE,gBAAgBxG,KAAKyG,kBAAmB,CAC3CvD,iBAAa,EACbC,cAAU,IAGZnD,KAAKwD,OAAO5C,KACVZ,KAAKwC,QAAQ3B,mBAAmBb,MAAOmB,IACrCnB,KAAK8D,WAAa3C,EACb,KAAAuE,QAAO,GAAO,EAAM,KAI7B1F,KAAKwD,OAAO5C,KACVZ,KAAKwC,QAAQH,qBAAqBrC,MAAM,CAACsC,EAAQK,KAC/C3C,KAAKiE,kBAAoB,EACzBjE,KAAKgE,gBAAkBrB,EACnB3C,KAAKyG,kBAAoBnE,EACvB,UACA,WACF,KACJtC,KAAK+D,aAAezB,EAEpB,MAAMoE,EAAkB1G,KAAK2C,YAC7B3C,KAAK2C,YAAcA,EAEd,KAAA+C,OAAOgB,IAAoB/D,EAAaA,EAAY,IAG/D,GAGF,KAAQgE,QAAU,IACX3G,KAAKwC,QAAQiD,SAKlBzF,KAAK8D,WAAa9D,KAAK8D,YAAc9D,KAAKwC,QAAQ2C,YAE3CnF,KAAK8D,WAAW9D,KAAKwC,QAAQI,WAAa,QAAU,YANzD5C,KAAK8D,WAAa,KACX,GAQX,KAAQ2C,gBAAkB,IACnBzG,KAAKwC,QAAQiD,SAKlBzF,KAAK+D,aACH/D,KAAK+D,eACkC,oBAA/B/D,KAAKwC,QAAQoC,cACjB5E,KAAKwC,QAAQoC,gBACb5E,KAAKwC,QAAQoC,eAEZ5E,KAAK+D,eAVV/D,KAAK+D,aAAe,KACb,GAYH,KAAA6C,uBAAyB,CAC/BC,EACAzI,KAEM,MAAA0I,EAAA,IAAgClD,IAChCmD,EAAA,IAA2BnD,IACjC,IAAK,IAAIoD,EAAI5I,EAAQ,EAAG4I,GAAK,EAAGA,IAAK,CAC7B,MAAAC,EAAcJ,EAAaG,GAEjC,GAAIF,EAA0BI,IAAID,EAAYE,MAC5C,SAGF,MAAMC,EAA8BL,EAAqB3C,IACvD6C,EAAYE,MAWd,GARiC,MAA/BC,GACAH,EAAY1G,IAAM6G,EAA4B7G,IAEzBwG,EAAAM,IAAIJ,EAAYE,KAAMF,GAClCA,EAAY1G,IAAM6G,EAA4B7G,KAC7BuG,EAAAO,IAAIJ,EAAYE,MAAM,GAG9CL,EAA0BQ,OAAStH,KAAKwC,QAAQgD,MAClD,KAEJ,CAEA,OAAOuB,EAAqBO,OAAStH,KAAKwC,QAAQgD,MAC9C+B,MAAMC,KAAKT,EAAqBU,UAAUC,MAAK,CAACC,EAAGC,IAC7CD,EAAEpH,MAAQqH,EAAErH,IACPoH,EAAEvJ,MAAQwJ,EAAExJ,MAGduJ,EAAEpH,IAAMqH,EAAErH,MAChB,QACH,GAGN,KAAQsH,sBAAwB9K,GAC9B,IAAM,CACJiD,KAAKwC,QAAQ/B,MACbT,KAAKwC,QAAQqC,aACb7E,KAAKwC,QAAQ4C,aACbpF,KAAKwC,QAAQyC,WACbjF,KAAKwC,QAAQiD,WAEf,CAAChF,EAAOoE,EAAcO,EAAcH,EAAYQ,KAC9CzF,KAAK6D,4BAA8B,GAC5B,CACLpD,QACAoE,eACAO,eACAH,aACAQ,aAGJ,CACE9H,KAAK,IAIT,KAAQmK,gBAAkB/K,GACxB,IAAM,CAACiD,KAAK6H,wBAAyB7H,KAAK2D,iBAC1C,EACIlD,QAAOoE,eAAcO,eAAcH,aAAYQ,WACjD9B,K,MAEA,IAAK8B,EAGH,OAFAzF,KAAK0D,kBAAoB,GACzB1D,KAAK2D,cAAcuC,QACZ,GAG6B,IAAlClG,KAAK0D,kBAAkBzF,SACpB,KAAAyF,kBAAoB1D,KAAKwC,QAAQ+C,yBACjC,KAAA7B,kBAAkBW,SAAS0D,IAC9B/H,KAAK2D,cAAc0D,IAAIU,EAAKpK,IAAKoK,EAAKT,KAAK,KAIzC,MAAApI,EACJc,KAAK6D,4BAA4B5F,OAAS,EACtCM,KAAKW,OAAOc,KAAK6D,6BACjB,EACN7D,KAAK6D,4BAA8B,GAEnC,MAAMgD,EAAe7G,KAAK0D,kBAAkBsE,MAAM,EAAG9I,GAErD,IAAK,IAAIyB,EAAIzB,EAAKyB,EAAIF,EAAOE,IAAK,CAChC,IAAIsH,EAAiB,OAAA3K,EAAA0C,KAAK0D,kBAAkB/C,SAAvB,EAAArD,EAA2B0F,eAE3CiF,IACHA,EAAkBC,IACV,MAAAC,EAAMlD,EAAWtE,GACjByH,EAAWpI,KAAKkE,cAAcE,IAAI+D,GAEnCD,GAQDE,IAAaF,IACXE,GACG,KAAA5G,SAASQ,UAAUoG,GAErB,KAAA5G,SAASO,QAAQmG,GACjB,KAAAhE,cAAcmD,IAAIc,EAAKD,IAG1BA,EAAKG,aACF,KAAAC,WACH3H,EACAX,KAAKwC,QAAQQ,eAAekF,OAAM,EAAWlI,QAlB3CoI,IACG,KAAA5G,SAASQ,UAAUoG,GACnB,KAAAlE,cAAcqE,OAAOJ,GAkB9B,GAIE,MAAAxK,EAAMsH,EAAWtE,GAEjB6H,EACmB,IAAvBxI,KAAKwC,QAAQgD,MACTqB,EAAalG,EAAI,GACjBX,KAAK4G,uBAAuBC,EAAclG,GAE1CP,EAAQoI,EACVA,EAAoBjI,IAAMP,KAAKwC,QAAQ6C,IACvCR,EAAeO,EAEbqD,EAAe9E,EAAcS,IAAIzG,GACjC2J,EACoB,kBAAjBmB,EACHA,EACAzI,KAAKwC,QAAQkG,aAAa/H,GAE1BJ,EAAMH,EAAQkH,EAEdH,EAAOqB,EACTA,EAAoBrB,KACpBxG,EAAIX,KAAKwC,QAAQgD,MAErBqB,EAAalG,GAAK,CAChBvC,MAAOuC,EACPP,QACAkH,OACA/G,MACA5C,MACAwJ,OACAnE,eAAAiF,EAEJ,CAIO,OAFPjI,KAAK0D,kBAAoBmD,EAElBA,CAAA,GAET,CACElJ,KAAKgL,EACL/K,MAAOA,IAAMoC,KAAKwC,QAAQ5E,QAIb,KAAAiI,eAAA9I,GACf,IAAM,CAACiD,KAAK8H,kBAAmB9H,KAAK2G,UAAW3G,KAAKyG,qBACpD,CAACI,EAAc+B,EAAW7E,IAChB/D,KAAKG,MACX0G,EAAa5I,OAAS,GAAK2K,EAAY,EAqX/C,UAAsD,aACpD/B,EAAA,UACA+B,EAAA,aACA7E,IAMM,MAAAtD,EAAQoG,EAAa5I,OAAS,EAC9B4K,EAAazK,GAAkByI,EAAazI,GAAQgC,MAEpDC,EAAayI,EAAwB,EAAGrI,EAAOoI,EAAW9E,GAChE,IAAIvD,EAAWH,EAEf,KACEG,EAAWC,GACXoG,EAAarG,GAAWD,IAAMwD,EAAe6E,GAE7CpI,IAGK,OAAEH,aAAYG,WACvB,CA3YYqF,CAAe,CACbgB,eACA+B,YACA7E,iBAEF,MAER,CACEpG,KAAKgL,EACL/K,MAAOA,IAAMoC,KAAKwC,QAAQ5E,QAI9B,KAAQmL,WAAahM,GACnB,IAAM,CACJiD,KAAKwC,QAAQ0C,eACblF,KAAK6F,iBACL7F,KAAKwC,QAAQlC,SACbN,KAAKwC,QAAQ/B,SAEf,CAACyE,EAAgB/E,EAAOG,EAAUG,IACf,OAAVN,EACH,GACA+E,EAAe,CACb7E,WAAYF,EAAME,WAClBG,SAAUL,EAAMK,SAChBF,WACAG,WAGR,CACE9C,KAAKgL,EACL/K,MAAOA,IAAMoC,KAAKwC,QAAQ5E,QAI9B,KAAAoL,iBAAoBd,IACZ,MAAAe,EAAgBjJ,KAAKwC,QAAQ8C,eAC7B4D,EAAWhB,EAAKiB,aAAaF,GAEnC,OAAKC,EAOEE,SAASF,EAAU,KANhBnK,QAAAsK,KACN,2BAA2BJ,oCAEtB,EAGoB,EAGvB,KAAA3E,gBAAkB,CACxB4D,EACAxG,KAEM,MAAAf,EAAIX,KAAKgJ,iBAAiBd,GAC1BH,EAAO/H,KAAK8H,kBAAkBnH,GAEpC,IAAKoH,IAASG,EAAKG,YAOjB,YANArI,KAAKkE,cAAcG,SAAQ,CAACiF,EAAQ3L,KAC9B2L,IAAWpB,IACR,KAAA1G,SAASQ,UAAUkG,GACnB,KAAAhE,cAAcqE,OAAO5K,GAC5B,IAKJ,MAAMyK,EAAWpI,KAAKkE,cAAcE,IAAI2D,EAAKpK,KAEzCyK,IAAaF,IACXE,GACG,KAAA5G,SAASQ,UAAUoG,GAErB,KAAA5G,SAASO,QAAQmG,GACtBlI,KAAKkE,cAAcmD,IAAIU,EAAKpK,IAAKuK,IAG9B,KAAAI,WAAW3H,EAAGX,KAAKwC,QAAQQ,eAAekF,EAAMxG,EAAO1B,MAAM,EAGvD,KAAAsI,WAAA,CAAClK,EAAekJ,KAC3B,MAAMS,EAAO/H,KAAK8H,kBAAkB1J,GACpC,IAAK2J,EACH,OAEF,MACMwB,EAAQjC,GADGtH,KAAK2D,cAAcS,IAAI2D,EAAKpK,MAAQoK,EAAKT,MAG5C,IAAViC,UAEoD,IAApDvJ,KAAKwJ,2CACDxJ,KAAKwJ,2CAA2CzB,EAAMwB,EAAOvJ,MAC7D+H,EAAK3H,MAAQJ,KAAKyG,kBAAoBzG,KAAKiE,oBAM1C,KAAAuC,gBAAgBxG,KAAKyG,kBAAmB,CAC3CvD,YAAclD,KAAKiE,mBAAqBsF,EACxCpG,cAAU,IAIT,KAAAU,4BAA4BjD,KAAKmH,EAAK3J,OACtC,KAAAuF,cAAgB,IAAIC,IAAI5D,KAAK2D,cAAc0D,IAAIU,EAAKpK,IAAK2J,IAEzD,KAAA5B,QAAO,GAAM,GACpB,EAGF,KAAA1C,eAAkBkF,IACXA,GAIA,KAAA5D,gBAAgB4D,OAAM,EAAU,EAGrB,KAAAuB,gBAAA1M,GAChB,IAAM,CAACiD,KAAK+I,aAAc/I,KAAK8H,qBAC/B,CAAC4B,EAAS7C,KACR,MAAM8C,EAAiD,GAEvD,IAAK,IAAIC,EAAI,EAAGC,EAAMH,EAAQzL,OAAQ2L,EAAIC,EAAKD,IAAK,CAC5C,MACA3C,EAAcJ,EADV6C,EAAQE,IAGlBD,EAAa/I,KAAKqG,EACpB,CAEO,OAAA0C,CAAA,GAET,CACEhM,KAAKgL,EACL/K,MAAOA,IAAMoC,KAAKwC,QAAQ5E,QAI9B,KAAAkM,wBAA2BxH,IACnB,MAAAuE,EAAe7G,KAAK8H,kBACtB,GAAwB,IAAxBjB,EAAa5I,OAGV,OAAAmB,EACLyH,EACEiC,EACE,EACAjC,EAAa5I,OAAS,GACrBG,GAAkBgB,EAAayH,EAAazI,IAAQgC,OACrDkC,IAEJ,EAIoB,KAAAyH,sBAAA,CAAC3G,EAAkB4G,KACnC,MAAA1C,EAAOtH,KAAK2G,UACZ5C,EAAe/D,KAAKyG,kBAEZ,SAAVuD,IAEQA,EADN5G,GAAYW,EACN,QACCX,GAAYW,EAAeuD,EAC5B,MAEA,SAIE,UAAV0C,IAEiB,QAAVA,EACT5G,GAAsBkE,EACH,WAAV0C,IACT5G,GAAsBkE,EAAO,IAG/B,MAAM2C,EAAiBjK,KAAKwC,QAAQI,WAChC,cACA,eAOEsH,GANalK,KAAKiB,cACpB,aAAcjB,KAAKiB,cACjBjB,KAAKiB,cAAckJ,SAASC,gBAAgBH,GAC5CjK,KAAKiB,cAAcgJ,GACrB,GAE2B3C,EAE/B,OAAO/I,KAAKU,IAAIV,KAAKW,IAAIgL,EAAW9G,GAAW,EAAE,EAG/B,KAAAiH,kBAAA,CAACjM,EAAe4L,EAAyB,UACnD5L,EAAAG,KAAKU,IAAI,EAAGV,KAAKW,IAAId,EAAO4B,KAAKwC,QAAQ/B,MAAQ,IAEzD,MAAMsH,EAAO/H,KAAK8H,kBAAkB1J,GACpC,IAAK2J,EACI,OAGH,MAAAT,EAAOtH,KAAK2G,UACZ5C,EAAe/D,KAAKyG,kBAE1B,GAAc,SAAVuD,EACF,GAAIjC,EAAKxH,KAAOwD,EAAeuD,EAAOtH,KAAKwC,QAAQwC,iBACzCgF,EAAA,gBACCjC,EAAK3H,OAAS2D,EAAe/D,KAAKwC,QAAQuC,oBAG5C,OAAChB,EAAciG,GAFdA,EAAA,OAGV,CAGI,MAAA5G,EACM,QAAV4G,EACIjC,EAAKxH,IAAMP,KAAKwC,QAAQwC,iBACxB+C,EAAK3H,MAAQJ,KAAKwC,QAAQuC,mBAEhC,MAAO,CAAC/E,KAAK+J,sBAAsB3G,EAAU4G,GAAQA,EAAM,EAG7D,KAAQM,cAAgB,IAAMtK,KAAKkE,cAAcoD,KAAO,EAExD,KAAQiD,oBAAsB,KACQ,OAAhCvK,KAAKyD,wBAAmCzD,KAAKP,eAC1C,KAAAA,aAAaI,aAAaG,KAAKyD,wBACpCzD,KAAKyD,uBAAyB,KAChC,EAGe,KAAA+G,eAAA,CACfpH,GACE4G,QAAQ,QAAS7G,YAAoC,CAAC,KAExDnD,KAAKuK,sBAEY,WAAbpH,GAAyBnD,KAAKsK,iBACxBvL,QAAAsK,KACN,0EAIJrJ,KAAKwG,gBAAgBxG,KAAK+J,sBAAsB3G,EAAU4G,GAAQ,CAChE9G,iBAAa,EACbC,YACA,EAGY,KAAAsH,cAAA,CACdrM,GACE4L,MAAOU,EAAe,OAAQvH,YAAmC,MAE3D/E,EAAAG,KAAKU,IAAI,EAAGV,KAAKW,IAAId,EAAO4B,KAAKwC,QAAQ/B,MAAQ,IAEzDT,KAAKuK,sBAEY,WAAbpH,GAAyBnD,KAAKsK,iBACxBvL,QAAAsK,KACN,0EAIJ,MAAMsB,EAAiB3K,KAAKqK,kBAAkBjM,EAAOsM,GACrD,IAAKC,EAAgB,OAEf,MAACrI,EAAQ0H,GAASW,EAExB3K,KAAKwG,gBAAgBlE,EAAQ,CAAEY,iBAAa,EAAWC,aAEtC,WAAbA,GAAyBnD,KAAKsK,iBAAmBtK,KAAKP,eACxDO,KAAKyD,uBAAyBzD,KAAKP,aAAaK,YAAW,KACzDE,KAAKyD,uBAAyB,KAM9B,GAJqBzD,KAAKkE,cAAcgD,IACtClH,KAAKwC,QAAQyC,WAAW7G,IAGR,CACV,MAACwM,GAAgBxL,EACrBY,KAAKqK,kBAAkBjM,EAAO4L,ID93BdrC,ECi4BDiD,EDj4BYhD,ECi4BE5H,KAAKyG,kBDj4BOlI,KAAKsM,IAAIlD,EAAIC,GAAK,GCk4B3D5H,KAAKyK,cAAcrM,EAAO,CAAE4L,QAAO7G,YACrC,MAEAnD,KAAKyK,cAAcrM,EAAO,CAAE4L,QAAO7G,aDr4BlB2H,IAACnD,EAAWC,CCs4B/B,IAEJ,EAGF,KAAAmD,SAAW,CAACxB,GAAiBpG,YAAoC,CAAC,KAChEnD,KAAKuK,sBAEY,WAAbpH,GAAyBnD,KAAKsK,iBACxBvL,QAAAsK,KACN,0EAIJrJ,KAAKwG,gBAAgBxG,KAAKyG,kBAAoB8C,EAAO,CACnDrG,iBAAa,EACbC,YACA,EAGJ,KAAA6H,aAAe,K,MACP,MAAAnE,EAAe7G,KAAK8H,kBAEtB,IAAAvH,EAcJ,OAXEA,EAD0B,IAAxBsG,EAAa5I,OACT+B,KAAKwC,QAAQqC,aAIM,IAAvB7E,KAAKwC,QAAQgD,OACT,OAAAlI,EAAAuJ,EAAaA,EAAa5I,OAAS,SAAnC,EAAAX,EAAuCiD,MAAO,EAC9ChC,KAAKU,OACA4H,EAAamB,OAAOhI,KAAKwC,QAAQgD,OAAOyF,KAAKjE,GAAMA,EAAEzG,OAI3DA,EAAMP,KAAKwC,QAAQ4C,aAAepF,KAAKwC,QAAQsC,UAAA,EAGhD,KAAA0B,gBAAkB,CACxBlE,GAEEY,cACAC,eAMFnD,KAAKwC,QAAQ0I,WAAW5I,EAAQ,CAAEa,WAAUD,eAAelD,KAAK,EAGlE,KAAAmL,QAAU,K,QACH,KAAAxH,cAAA,IAAoBC,IACpB,OAAArG,GAAAD,EAAA,KAAAkF,SAAQrD,WAAR5B,EAAAM,KAAAP,EAAmB0C,MAAM,EAAM,EAjpBpCA,KAAKyE,WAAWvH,EAClB,EAopBF,MAAM4L,EAA0BA,CAC9BsC,EACAC,EACAC,EACAjM,KAEA,KAAO+L,GAAOC,GAAM,CACZ,MAAAE,GAAWH,EAAMC,GAAQ,EAAK,EAC9BG,EAAeF,EAAgBC,GAErC,GAAIC,EAAenM,EACjB+L,EAAMG,EAAS,YACNC,EAAenM,GAGjB,OAAAkM,EAFPF,EAAOE,EAAS,CAGlB,CACF,CAEA,OAAIH,EAAM,EACDA,EAAM,EAEN,CACT,ECvhCF,MAAMK,EACgB,qBAAbtB,SAA2BuB,EAAAA,gBAAwBA,EAAAA,UAE5D,SAASC,EAIPnJ,GAEM,MAAAoJ,EAAWF,EAAAA,YAAiB,KAAM,CAAM,KAAE,GAAE,GAE5CG,EAAoE,IACrErJ,EACHrD,SAAUA,CAAC2M,EAAUlG,K,MACfA,GACFmG,EAAAA,EAAAA,WAAUH,GAEDA,IAEH,OAAAtO,EAAAkF,EAAArD,WAAA7B,EAAAO,KAAA2E,EAAWsJ,EAAUlG,EAAA,IAI1B9E,GAAY4K,EAAAA,UACjB,IAAM,IAAIpI,EAA0CuI,KAa/C,OAVP/K,EAAS2D,WAAWoH,GAEpBH,EAAAA,WAAgB,IACP5K,EAASqF,aACf,IAEHsF,GAA0B,IACjB3K,EAASsF,gBAGXtF,CACT,CAEO,SAASkL,EAIdxJ,GAKA,OAAOmJ,EAAiD,CACtD9K,mBAAAA,EACAwB,qBAAAA,EACA6I,WAAYjI,KACTT,GAEP,C,gGC4CwB,SAAAyJ,EAEtBC,EAASC,EAAeF,GAAiB,IAAAtL,EAAA,KACnCgH,GAAeyE,EAAAA,EAAAA,QAAO,MACtBC,GAAiBD,EAAAA,EAAAA,QAAO,GACxBE,GAAUF,EAAAA,EAAAA,QAAO,MACjBG,GAAWH,EAAAA,EAAAA,QAAkB,IAC7BI,GAAWJ,EAAAA,EAAAA,UACXpF,GAASoF,EAAAA,EAAAA,UACTnG,GAAUmG,EAAAA,EAAAA,QAAOF,GACjBO,GAAUL,EAAAA,EAAAA,SAAA,GAEhBnG,EAAQyG,QAAUR,EAElB,IAAMS,EAAiC,oBAAXvK,OAEtBwK,GAAUT,GAAiB,IAATA,GAAcQ,EAEtC,GAAoB,mBAATT,EACT,MAAU,IAAAW,UAAU,uBAGtBV,GAAQA,GAAQ,EAGhB,IAAMW,KAFNb,EAAUA,GAAW,CAAE,GAEGc,QACpBC,IAAW,aAAcf,MAAYA,EAAQgB,SAC7CC,EAAS,YAAajB,EACtBkB,EACJ,qBAAsBlB,KAAYA,EAAQmB,iBACtCC,EAAUH,EAAS3O,KAAKU,KAAKgN,EAAQqB,SAAW,EAAGnB,GAAQ,MAEjEoB,EAAAA,EAAAA,YAAU,WAER,OADAd,EAAQC,SAAA,EAAU,WAEhBD,EAAQC,SAAA,CACV,CACF,GAAG,IAYH,IAAMc,GAAYC,EAAAA,EAAAA,UAAQ,WACxB,IAAMrB,EAAa,SAACA,GAClB,IAAMmB,EAAOhB,EAASG,QAChBe,EAAUjB,EAASE,QAIzB,OAFAH,EAASG,QAAUF,EAASE,QAAU,KACtCL,EAAeK,QAAUN,EACjBpF,EAAO0F,QAAUzG,EAAQyG,QAAQ3M,MAAM0N,EAASF,EAC1D,EAEMA,EAAa,SAACnB,EAAyBmB,GACvCX,GAAQc,qBAAqBpB,EAAQI,SACzCJ,EAAQI,QAAUE,EACde,sBAAsBvB,GACtBtM,WAAWsM,EAAamB,EAC9B,EAEME,EAAe,SAACrB,GACpB,IAAKK,EAAQC,QAAS,OAAO,EAE7B,IAAMa,EAAoBnB,EAAOzE,EAAa+E,QAM9C,OACG/E,EAAa+E,SACda,GAAqBpB,GACrBoB,EAAoB,GACnBL,GATyBd,EAAOC,EAAeK,SASdW,CAEtC,EAEMnB,EAAe,SAACqB,GAKpB,OAJAjB,EAAQI,QAAU,KAIdM,GAAYT,EAASG,QAChBN,EAAWmB,IAEpBhB,EAASG,QAAUF,EAASE,QAAU,KAC/B1F,EAAO0F,QAChB,EAEMT,EAAe,SAAfG,IACJ,IAAMH,EAAOnO,KAAKC,MAClB,GAAI0P,EAAaxB,GACf,OAAOC,EAAaD,GAGtB,GAAKQ,EAAQC,QAAb,CAIA,IAEM/L,EAAcwL,GAFMF,EAAOtE,EAAa+E,SAGxCJ,EAAgBY,EAClB3O,KAAKW,IAAIyB,EAAa0M,GAHEpB,EAAOI,EAAeK,UAI9C/L,EAGJ4M,EAAWnB,EAAcE,EAVxB,CAWH,EAEMkB,EAA0B,WAC9B,GAAKb,GAAiBQ,EAAtB,CAGA,IAAMjB,EAAOpO,KAAKC,MACZkI,EAAawH,EAAavB,GAMhC,GAJAK,EAASG,QAAO,GAAA1E,MAAAnK,KAAA+P,WAChBpB,EAASE,QAAU/L,EACnBgH,EAAa+E,QAAUR,EAEnBjG,EAAY,CACd,IAAKqG,EAAQI,SAAWD,EAAQC,QAM9B,OAJAL,EAAeK,QAAU/E,EAAa+E,QAEtCa,EAAWtB,EAAcE,GAElBW,EAAUV,EAAWzE,EAAa+E,SAAW1F,EAAO0F,QAE7D,GAAIQ,EAGF,OADAK,EAAWtB,EAAcE,GAClBC,EAAWzE,EAAa+E,QAElC,CAID,OAHKJ,EAAQI,SACXa,EAAWtB,EAAcE,GAEpBnF,EAAO0F,OA1Bb,CA2BH,EAwBA,OAtBAc,EAAKK,OAAS,WACRvB,EAAQI,UACVE,EACIc,qBAAqBpB,EAAQI,SAC7B7M,aAAayM,EAAQI,UAE3BL,EAAeK,QAAU,EACzBH,EAASG,QACP/E,EAAa+E,QACbF,EAASE,QACTJ,EAAQI,QACN,IACN,EAEAc,EAAKM,UAAY,WACf,QAASxB,EAAQI,OACnB,EAEAc,EAAKO,MAAQ,WACX,OAAQzB,EAAQI,QAA2BR,EAAapO,KAAKC,OAAnCiJ,EAAO0F,OACnC,EAEOc,CACT,GAAG,CACDV,EACAI,EACAf,EACAkB,EACAL,EACAJ,EACAD,EACAQ,IAGF,OAAOK,CACT,CCtSA,SAAS7M,EAAiByL,EAASmB,GACjC,OAAOnB,IAASmB,CAClB,CAEwB,SAAA5F,EACtB4F,EACAE,EACA9F,GAOA,IAAM0E,EAAM1E,GAAWA,EAAQqG,YAAerN,EAExC2L,GAAcF,EAAAA,EAAAA,QAAOmB,GAClBhB,GAAeL,EAAAA,EAAAA,UAAS,CAAE,GACnC,GAAMM,EAAYP,GAChBE,EAAAA,EAAAA,cACE,SAACC,GACCE,EAAYI,QAAUN,EACtBG,EAAY,CAAE,EAChB,GACA,CAACA,IAEHkB,EACA9F,GAEIX,GAAgBoF,EAAAA,EAAAA,QAAOmB,GAO7B,OALKlB,EAAGrF,EAAc0F,QAASa,KAC7Bf,EAAUe,GACVvG,EAAc0F,QAAUa,GAGnB,CAACjB,EAAYI,QAAcF,EACpC,C,8HC1BO,MAAMyB,UAAwBC,EAAAA,EAOnC3K,WAAAA,CAAY4K,EAAqBC,GAC/BC,QAEArO,KAAKmO,OAASA,EACdnO,KAAKoO,QAAU,GACfpO,KAAK7C,OAAS,GACd6C,KAAKsO,UAAY,GACjBtO,KAAKuO,aAAe,CAAC,EAEjBH,GACFpO,KAAKwO,WAAWJ,EAEnB,CAESK,WAAAA,GACoB,IAAxBzO,KAAK0O,UAAUpH,MACjBtH,KAAKsO,UAAUjK,SAAS7C,IACtBA,EAASmN,WAAWxR,IAClB6C,KAAK4O,SAASpN,EAAUrE,EAAxB,GADF,GAKL,CAES0R,aAAAA,GACH7O,KAAK0O,UAAUpH,MAClBtH,KAAK8O,SAER,CAEDA,OAAAA,GACE9O,KAAK0O,UAAY,IAAIK,IACrB/O,KAAKsO,UAAUjK,SAAS7C,IACtBA,EAASsN,SAAT,GAEH,CAEDN,UAAAA,CACEJ,EACAY,GAEAhP,KAAKoO,QAAUA,EAEfa,EAAAA,EAAcC,OAAM,KAClB,MAAMC,EAAgBnP,KAAKsO,UAErBc,EAAqBpP,KAAKqP,sBAAsBrP,KAAKoO,SAG3DgB,EAAmB/K,SAASiL,GAC1BA,EAAM9N,SAASiD,WAAW6K,EAAMC,sBAAuBP,KAGzD,MAAMQ,EAAeJ,EAAmBnE,KAAKqE,GAAUA,EAAM9N,WACvDiO,EAAkB9K,OAAO+K,YAC7BF,EAAavE,KAAKzJ,GAAa,CAACA,EAASgB,QAAQmN,UAAWnO,MAExDoO,EAAYJ,EAAavE,KAAKzJ,GAClCA,EAASqO,qBAGLC,EAAiBN,EAAatR,MAClC,CAACsD,EAAUpD,IAAUoD,IAAa2N,EAAc/Q,MAE9C+Q,EAAclR,SAAWuR,EAAavR,QAAW6R,KAIrD9P,KAAKsO,UAAYkB,EACjBxP,KAAKuO,aAAekB,EACpBzP,KAAK7C,OAASyS,EAET5P,KAAK+P,kBAIVC,EAAAA,EAAAA,IAAWb,EAAeK,GAAcnL,SAAS7C,IAC/CA,EAASsN,SAAT,KAGFkB,EAAAA,EAAAA,IAAWR,EAAcL,GAAe9K,SAAS7C,IAC/CA,EAASmN,WAAWxR,IAClB6C,KAAK4O,SAASpN,EAAUrE,EAAxB,GADF,IAKF6C,KAAK0F,UAAL,GAEH,CAEDmK,gBAAAA,GACE,OAAO7P,KAAK7C,MACb,CAED8S,UAAAA,GACE,OAAOjQ,KAAKsO,UAAUrD,KAAKzJ,GAAaA,EAAS0O,mBAClD,CAEDC,YAAAA,GACE,OAAOnQ,KAAKsO,SACb,CAED8B,mBAAAA,CAAoBhC,GAClB,OAAOpO,KAAKqP,sBAAsBjB,GAASnD,KAAKqE,GAC9CA,EAAM9N,SAAS4O,oBAAoBd,EAAMC,wBAE5C,CAEOF,qBAAAA,CACNjB,GAEA,MAAMe,EAAgBnP,KAAKsO,UACrB+B,EAAmB,IAAIzM,IAC3BuL,EAAclE,KAAKzJ,GAAa,CAACA,EAASgB,QAAQmN,UAAWnO,MAGzD+N,EAAwBnB,EAAQnD,KAAKzI,GACzCxC,KAAKmO,OAAOmC,oBAAoB9N,KAG5B+N,EACJhB,EAAsBiB,SAASC,IAC7B,MAAMnB,EAAQe,EAAiBjM,IAAIqM,EAAiBd,WACpD,OAAa,MAATL,EACK,CAAC,CAAEC,sBAAuBkB,EAAkBjP,SAAU8N,IAExD,EAAP,IAGEoB,EAAqB,IAAI3B,IAC7BwB,EAAkBtF,KAAKqE,GAAUA,EAAMC,sBAAsBI,aAEzDgB,EAAmBpB,EAAsBxJ,QAC5C0K,IAAsBC,EAAmBxJ,IAAIuJ,EAAiBd,aAG3DiB,EAAuB,IAAI7B,IAC/BwB,EAAkBtF,KAAKqE,GAAUA,EAAM9N,YAEnCqP,EAAqB1B,EAAcpJ,QACtC+K,IAAkBF,EAAqB1J,IAAI4J,KAGxCC,EAAevO,IACnB,MAAMiO,EAAmBzQ,KAAKmO,OAAOmC,oBAAoB9N,GACnDwO,EAAkBhR,KAAKuO,aAAakC,EAAiBd,WAC3D,OAAO,MAAAqB,EAAAA,EAAmB,IAAIC,EAAAA,EAAcjR,KAAKmO,OAAQsC,EAAzD,EAGIS,EAA6CP,EAAiB1F,KAClE,CAACzI,EAASpE,KACR,GAAIoE,EAAQ2O,iBAAkB,CAE5B,MAAMC,EAAyBP,EAAmBzS,GAClD,QAA+BiT,IAA3BD,EACF,MAAO,CACL7B,sBAAuB/M,EACvBhB,SAAU4P,EAGf,CACD,MAAO,CACL7B,sBAAuB/M,EACvBhB,SAAUuP,EAAYvO,GAFxB,IAcJ,OAAO+N,EACJe,OAAOJ,GACPxJ,MATiC6J,CAClC5J,EACAC,IAEA2H,EAAsBiC,QAAQ7J,EAAE4H,uBAChCA,EAAsBiC,QAAQ5J,EAAE2H,wBAKnC,CAEOX,QAAAA,CAASpN,EAAyBrE,GACxC,MAAMiB,EAAQ4B,KAAKsO,UAAUkD,QAAQhQ,IACtB,IAAXpD,IACF4B,KAAK7C,QAASsU,EAAAA,EAAAA,IAAUzR,KAAK7C,OAAQiB,EAAOjB,GAC5C6C,KAAK0F,SAER,CAEOA,MAAAA,GACNuJ,EAAAA,EAAcC,OAAM,KAClBlP,KAAK0O,UAAUrK,SAAQ,EAAGqN,eACxBA,EAAS1R,KAAK7C,OAAd,GADF,GAIH,E,2DCjEI,SAASwU,GAA4B,QAC1CvD,EAD0C,QAE1CwD,IAKA,MAAMC,GAAcC,EAAAA,EAAAA,IAAe,CAAEF,YAC/BG,GAAcC,EAAAA,EAAAA,KACdC,GAAqBC,EAAAA,EAAAA,KAErBC,EAAmBzG,EAAAA,SACvB,IACE0C,EAAQnD,KAAKzI,IACX,MAAMiO,EAAmBoB,EAAYvB,oBAAoB9N,GAOzD,OAJAiO,EAAiB2B,mBAAqBL,EAClC,cACA,aAEGtB,CAAP,KAEJ,CAACrC,EAASyD,EAAaE,IAGzBI,EAAiB9N,SAASgO,KACxBC,EAAAA,EAAAA,IAAgBD,IAChBE,EAAAA,EAAAA,IAAgCF,EAAOJ,EAAvC,KAGFO,EAAAA,EAAAA,IAA2BP,GAE3B,MAAOzQ,GAAYkK,EAAAA,UACjB,IAAM,IAAIuC,EAAgB4D,EAAaM,KAGnCM,EAAmBjR,EAAS4O,oBAAoB+B,IAEtDO,EAAAA,EAAAA,GACEhH,EAAAA,aACGiH,GACCZ,EACI,KADO,EAEPvQ,EAASmN,UAAUM,EAAAA,EAAc2D,WAAWD,KAClD,CAACnR,EAAUuQ,KAEb,IAAMvQ,EAASqO,qBACf,IAAMrO,EAASqO,qBAGjBnE,EAAAA,WAAgB,KAGdlK,EAASgN,WAAW2D,EAAkB,CAAEzD,WAAW,GAAnD,GACC,CAACyD,EAAkB3Q,IAEtB,MAIMqR,EAJ0BJ,EAAiBvU,MAAK,CAACf,EAAQiB,KAC7D0U,EAAAA,EAAAA,IAAcX,EAAiB/T,GAAQjB,EAAQ4U,KAI7CU,EAAiBjC,SAAQ,CAACrT,EAAQiB,KAChC,MAAMoE,EAAU2P,EAAiB/T,GAC3B2U,EAAgBvR,EAAS2O,eAAe/R,GAE9C,GAAIoE,GAAWuQ,EAAe,CAC5B,IAAID,EAAAA,EAAAA,IAActQ,EAASrF,EAAQ4U,GACjC,OAAOiB,EAAAA,EAAAA,IAAgBxQ,EAASuQ,EAAed,IACtCgB,EAAAA,EAAAA,IAAU9V,EAAQ4U,KACtBiB,EAAAA,EAAAA,IAAgBxQ,EAASuQ,EAAed,EAEhD,CACD,MAAO,EAAP,IAEF,GAEJ,GAAIY,EAAiB5U,OAAS,EAC5B,MAAMiV,QAAQC,IAAIN,GAEpB,MAAMO,EAAkB5R,EAASyO,aAC3BoD,EAAoCZ,EAAiBa,MACzD,CAACnW,EAAQiB,KAAT,IAAAmV,EAAAC,EAAA,OACEC,EAAAA,EAAAA,IAAY,CACVtW,SACA8U,qBACAyB,iBAAgB,OAAAH,EAAE,OAAFC,EAAErB,EAAiB/T,SAAjB,EAAAoV,EAAyBE,mBAA3BH,EAChBlB,MAAOe,EAAgBhV,IAL3B,IASF,SAAIiV,GAAAA,EAAmCM,MACrC,MAAMN,EAAkCM,MAG1C,OAAOlB,CACR,C,wBCrPD,IAAImB,EAAmB5T,MAAQA,KAAK4T,iBAAoB,SAAUC,GAC9D,OAAQA,GAAOA,EAAIC,WAAcD,EAAM,CAAE,QAAWA,EACxD,EACAlP,OAAOoP,eAAeC,EAAS,aAAc,CAAE3U,OAAO,IACtD2U,EAAQC,kBAAe,EACvB,IAAIC,EAAmBN,EAAgBO,EAAQ,QAC3CC,EAAUD,EAAQ,OAClBE,EAAmBF,EAAQ,OAC/B,SAASG,EAAYpM,GACjB,OAAOA,IAA2B,aAAlBA,EAAKqM,UAA6C,UAAlBrM,EAAKqM,SACzD,CAoDAP,EAAQC,aAnDR,SAAsBzR,QACF,IAAZA,IAAsBA,EAAU,CAAC,GACrC,IAAIlF,EAAK+W,EAAiBG,gBAAe,GAAQC,EAASnX,EAAG,GAAIoX,EAAepX,EAAG,GAC/EqX,EAAYP,EAAQQ,OAAO,MAC3BC,EAAaT,EAAQQ,OAAOpS,GAwChC,OAvCAqS,EAAWnI,QAAUlK,EAuCd,CACHiS,OAAQA,EACRK,KAlCcV,EAAQW,aAAY,SAAUC,GAC5C,IAAI9X,EAAO2X,EAAWnI,QAClBnI,EAASoQ,EAAUjI,QACvB,SAASuI,IACD/X,EAAKgY,WACLhY,EAAKgY,YAELhY,EAAKiY,eACLT,EAAaxX,EAAKiY,eAElBjY,EAAKkY,cAAgBd,EAAY/P,IACjCA,EAAO8Q,QAEf,CACA,SAASC,IACDpY,EAAKqY,SACLrY,EAAKqY,WAEkB,IAAvBrY,EAAKsY,eAA2BlB,EAAY/P,IAC5CA,EAAO8Q,QAEf,CACA,SAASP,EAAKzV,GACV6U,EAAiBuB,QAAQpW,GAAOqW,KAAKT,GAAeU,MAAML,EAC9D,CACoB,kBAATN,EACPF,EAAKE,GAEAzQ,GACLuQ,EAAKvQ,EAAOlF,MAEpB,GAAG,IAICuW,YAzCJ,WACI,QAAUC,UAAUC,WACiB,oBAAzB3L,SAAS4L,aAC6B,oBAAnC5L,SAAS6L,uBAChB7L,SAAS6L,sBAAsB,OAC3C,EAqCIzR,OAAQoQ,EAEhB,C","sources":["../node_modules/@tanstack/virtual-core/src/utils.ts","../node_modules/@tanstack/virtual-core/src/index.ts","../node_modules/@tanstack/react-virtual/src/index.tsx","../node_modules/use-debounce/src/useDebouncedCallback.ts","../node_modules/use-debounce/src/useDebounce.ts","../node_modules/@tanstack/query-core/src/queriesObserver.ts","../node_modules/@tanstack/react-query/src/useQueries.ts","../node_modules/use-clipboard-copy/dist/index.js"],"sourcesContent":["export type NoInfer<A extends any> = [A][A extends any ? 0 : never]\n\nexport type PartialKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\n\nexport function memo<TDeps extends ReadonlyArray<any>, TResult>(\n  getDeps: () => [...TDeps],\n  fn: (...args: NoInfer<[...TDeps]>) => TResult,\n  opts: {\n    key: false | string\n    debug?: () => any\n    onChange?: (result: TResult) => void\n    initialDeps?: TDeps\n  },\n) {\n  let deps = opts.initialDeps ?? []\n  let result: TResult | undefined\n\n  return (): TResult => {\n    let depTime: number\n    if (opts.key && opts.debug?.()) depTime = Date.now()\n\n    const newDeps = getDeps()\n\n    const depsChanged =\n      newDeps.length !== deps.length ||\n      newDeps.some((dep: any, index: number) => deps[index] !== dep)\n\n    if (!depsChanged) {\n      return result!\n    }\n\n    deps = newDeps\n\n    let resultTime: number\n    if (opts.key && opts.debug?.()) resultTime = Date.now()\n\n    result = fn(...newDeps)\n\n    if (opts.key && opts.debug?.()) {\n      const depEndTime = Math.round((Date.now() - depTime!) * 100) / 100\n      const resultEndTime = Math.round((Date.now() - resultTime!) * 100) / 100\n      const resultFpsPercentage = resultEndTime / 16\n\n      const pad = (str: number | string, num: number) => {\n        str = String(str)\n        while (str.length < num) {\n          str = ' ' + str\n        }\n        return str\n      }\n\n      console.info(\n        `%câ± ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n              0,\n              Math.min(120 - 120 * resultFpsPercentage, 120),\n            )}deg 100% 31%);`,\n        opts?.key,\n      )\n    }\n\n    opts?.onChange?.(result)\n\n    return result\n  }\n}\n\nexport function notUndefined<T>(value: T | undefined, msg?: string): T {\n  if (value === undefined) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : ''}`)\n  } else {\n    return value\n  }\n}\n\nexport const approxEqual = (a: number, b: number) => Math.abs(a - b) < 1\n\nexport const debounce = (\n  targetWindow: Window & typeof globalThis,\n  fn: Function,\n  ms: number,\n) => {\n  let timeoutId: number\n  return function (this: any, ...args: Array<any>) {\n    targetWindow.clearTimeout(timeoutId)\n    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms)\n  }\n}\n","import { approxEqual, debounce, memo, notUndefined } from './utils'\n\nexport * from './utils'\n\n//\n\ntype ScrollDirection = 'forward' | 'backward'\n\ntype ScrollAlignment = 'start' | 'center' | 'end' | 'auto'\n\ntype ScrollBehavior = 'auto' | 'smooth'\n\nexport interface ScrollToOptions {\n  align?: ScrollAlignment\n  behavior?: ScrollBehavior\n}\n\ntype ScrollToOffsetOptions = ScrollToOptions\n\ntype ScrollToIndexOptions = ScrollToOptions\n\nexport interface Range {\n  startIndex: number\n  endIndex: number\n  overscan: number\n  count: number\n}\n\ntype Key = number | string\n\nexport interface VirtualItem<TItemElement extends Element> {\n  key: Key\n  index: number\n  start: number\n  end: number\n  size: number\n  lane: number\n  measureElement: (node: TItemElement | null | undefined) => void\n}\n\nexport interface Rect {\n  width: number\n  height: number\n}\n\n//\n\nexport const defaultKeyExtractor = (index: number) => index\n\nexport const defaultRangeExtractor = (range: Range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0)\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1)\n\n  const arr = []\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i)\n  }\n\n  return arr\n}\n\nexport const observeElementRect = <T extends Element>(\n  instance: Virtualizer<T, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  const handler = (rect: Rect) => {\n    const { width, height } = rect\n    cb({ width: Math.round(width), height: Math.round(height) })\n  }\n\n  handler(element.getBoundingClientRect())\n\n  if (!targetWindow.ResizeObserver) {\n    return () => {}\n  }\n\n  const observer = new targetWindow.ResizeObserver((entries) => {\n    const entry = entries[0]\n    if (entry?.borderBoxSize) {\n      const box = entry.borderBoxSize[0]\n      if (box) {\n        handler({ width: box.inlineSize, height: box.blockSize })\n        return\n      }\n    }\n    handler(element.getBoundingClientRect())\n  })\n\n  observer.observe(element, { box: 'border-box' })\n\n  return () => {\n    observer.unobserve(element)\n  }\n}\n\nconst addEventListenerOptions = {\n  passive: true,\n}\n\nexport const observeWindowRect = (\n  instance: Virtualizer<Window, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight })\n  }\n  handler()\n\n  element.addEventListener('resize', handler, addEventListenerOptions)\n\n  return () => {\n    element.removeEventListener('resize', handler)\n  }\n}\n\nconst supportsScrollend =\n  typeof window == 'undefined' ? true : 'onscrollend' in window\n\nexport const observeElementOffset = <T extends Element>(\n  instance: Virtualizer<T, any>,\n  cb: (offset: number, isScrolling: boolean) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  let offset = 0\n  const fallback = supportsScrollend\n    ? () => undefined\n    : debounce(\n        targetWindow,\n        () => {\n          cb(offset, false)\n        },\n        instance.options.isScrollingResetDelay,\n      )\n\n  const createHandler = (isScrolling: boolean) => () => {\n    offset = element[instance.options.horizontal ? 'scrollLeft' : 'scrollTop']\n    fallback()\n    cb(offset, isScrolling)\n  }\n  const handler = createHandler(true)\n  const endHandler = createHandler(false)\n  endHandler()\n\n  element.addEventListener('scroll', handler, addEventListenerOptions)\n  element.addEventListener('scrollend', endHandler, addEventListenerOptions)\n\n  return () => {\n    element.removeEventListener('scroll', handler)\n    element.removeEventListener('scrollend', endHandler)\n  }\n}\n\nexport const observeWindowOffset = (\n  instance: Virtualizer<Window, any>,\n  cb: (offset: number, isScrolling: boolean) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  let offset = 0\n  const fallback = supportsScrollend\n    ? () => undefined\n    : debounce(\n        targetWindow,\n        () => {\n          cb(offset, false)\n        },\n        instance.options.isScrollingResetDelay,\n      )\n\n  const createHandler = (isScrolling: boolean) => () => {\n    offset = element[instance.options.horizontal ? 'scrollX' : 'scrollY']\n    fallback()\n    cb(offset, isScrolling)\n  }\n  const handler = createHandler(true)\n  const endHandler = createHandler(false)\n  endHandler()\n\n  element.addEventListener('scroll', handler, addEventListenerOptions)\n  element.addEventListener('scrollend', endHandler, addEventListenerOptions)\n\n  return () => {\n    element.removeEventListener('scroll', handler)\n    element.removeEventListener('scrollend', endHandler)\n  }\n}\n\nexport const measureElement = <TItemElement extends Element>(\n  element: TItemElement,\n  entry: ResizeObserverEntry | undefined,\n  instance: Virtualizer<any, TItemElement>,\n) => {\n  if (entry?.borderBoxSize) {\n    const box = entry.borderBoxSize[0]\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? 'inlineSize' : 'blockSize'],\n      )\n      return size\n    }\n  }\n  return Math.round(\n    element.getBoundingClientRect()[\n      instance.options.horizontal ? 'width' : 'height'\n    ],\n  )\n}\n\nexport const windowScroll = <T extends Window>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport const elementScroll = <T extends Element>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport interface VirtualizerOptions<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  // Required from the user\n  count: number\n  getScrollElement: () => TScrollElement | null\n  estimateSize: (index: number) => number\n\n  // Required from the framework adapter (but can be overridden)\n  scrollToFn: (\n    offset: number,\n    options: { adjustments?: number; behavior?: ScrollBehavior },\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => void\n  observeElementRect: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: (rect: Rect) => void,\n  ) => void | (() => void)\n  observeElementOffset: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: (offset: number, isScrolling: boolean) => void,\n  ) => void | (() => void)\n\n  // Optional\n  debug?: any\n  initialRect?: Rect\n  onChange?: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    sync: boolean,\n  ) => void\n  measureElement?: (\n    element: TItemElement,\n    entry: ResizeObserverEntry | undefined,\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => number\n  overscan?: number\n  horizontal?: boolean\n  paddingStart?: number\n  paddingEnd?: number\n  scrollPaddingStart?: number\n  scrollPaddingEnd?: number\n  initialOffset?: number | (() => number)\n  getItemKey?: (index: number) => Key\n  rangeExtractor?: (range: Range) => Array<number>\n  scrollMargin?: number\n  gap?: number\n  indexAttribute?: string\n  initialMeasurementsCache?: Array<VirtualItem<TItemElement>>\n  lanes?: number\n  isScrollingResetDelay?: number\n  enabled?: boolean\n}\n\nexport class Virtualizer<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  private unsubs: Array<void | (() => void)> = []\n  options!: Required<VirtualizerOptions<TScrollElement, TItemElement>>\n  scrollElement: TScrollElement | null = null\n  targetWindow: (Window & typeof globalThis) | null = null\n  isScrolling = false\n  private scrollToIndexTimeoutId: number | null = null\n  measurementsCache: Array<VirtualItem<TItemElement>> = []\n  private itemSizeCache = new Map<Key, number>()\n  private pendingMeasuredCacheIndexes: Array<number> = []\n  scrollRect: Rect | null = null\n  scrollOffset: number | null = null\n  scrollDirection: ScrollDirection | null = null\n  private scrollAdjustments = 0\n  shouldAdjustScrollPositionOnItemSizeChange:\n    | undefined\n    | ((\n        item: VirtualItem<TItemElement>,\n        delta: number,\n        instance: Virtualizer<TScrollElement, TItemElement>,\n      ) => boolean)\n  elementsCache = new Map<Key, TItemElement>()\n  private observer = (() => {\n    let _ro: ResizeObserver | null = null\n\n    const get = () => {\n      if (_ro) {\n        return _ro\n      }\n\n      if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n        return null\n      }\n\n      return (_ro = new this.targetWindow.ResizeObserver((entries) => {\n        entries.forEach((entry) => {\n          this._measureElement(entry.target as TItemElement, entry)\n        })\n      }))\n    }\n\n    return {\n      disconnect: () => get()?.disconnect(),\n      observe: (target: Element) =>\n        get()?.observe(target, { box: 'border-box' }),\n      unobserve: (target: Element) => get()?.unobserve(target),\n    }\n  })()\n  range: { startIndex: number; endIndex: number } | null = null\n\n  constructor(opts: VirtualizerOptions<TScrollElement, TItemElement>) {\n    this.setOptions(opts)\n  }\n\n  setOptions = (opts: VirtualizerOptions<TScrollElement, TItemElement>) => {\n    Object.entries(opts).forEach(([key, value]) => {\n      if (typeof value === 'undefined') delete (opts as any)[key]\n    })\n\n    this.options = {\n      debug: false,\n      initialOffset: 0,\n      overscan: 1,\n      paddingStart: 0,\n      paddingEnd: 0,\n      scrollPaddingStart: 0,\n      scrollPaddingEnd: 0,\n      horizontal: false,\n      getItemKey: defaultKeyExtractor,\n      rangeExtractor: defaultRangeExtractor,\n      onChange: () => {},\n      measureElement,\n      initialRect: { width: 0, height: 0 },\n      scrollMargin: 0,\n      gap: 0,\n      indexAttribute: 'data-index',\n      initialMeasurementsCache: [],\n      lanes: 1,\n      isScrollingResetDelay: 150,\n      enabled: true,\n      ...opts,\n    }\n  }\n\n  private notify = (force: boolean, sync: boolean) => {\n    const { startIndex, endIndex } = this.range ?? {\n      startIndex: undefined,\n      endIndex: undefined,\n    }\n    const range = this.calculateRange()\n\n    if (\n      force ||\n      startIndex !== range?.startIndex ||\n      endIndex !== range?.endIndex\n    ) {\n      this.options.onChange?.(this, sync)\n    }\n  }\n\n  private cleanup = () => {\n    this.unsubs.filter(Boolean).forEach((d) => d!())\n    this.unsubs = []\n    this.scrollElement = null\n    this.targetWindow = null\n    this.observer.disconnect()\n    this.elementsCache.clear()\n  }\n\n  _didMount = () => {\n    return () => {\n      this.cleanup()\n    }\n  }\n\n  _willUpdate = () => {\n    const scrollElement = this.options.enabled\n      ? this.options.getScrollElement()\n      : null\n\n    if (this.scrollElement !== scrollElement) {\n      this.cleanup()\n\n      if (!scrollElement) {\n        this.notify(false, false)\n        return\n      }\n\n      this.scrollElement = scrollElement\n\n      if (this.scrollElement && 'ownerDocument' in this.scrollElement) {\n        this.targetWindow = this.scrollElement.ownerDocument.defaultView\n      } else {\n        this.targetWindow = this.scrollElement?.window ?? null\n      }\n\n      this._scrollToOffset(this.getScrollOffset(), {\n        adjustments: undefined,\n        behavior: undefined,\n      })\n\n      this.unsubs.push(\n        this.options.observeElementRect(this, (rect) => {\n          this.scrollRect = rect\n          this.notify(false, false)\n        }),\n      )\n\n      this.unsubs.push(\n        this.options.observeElementOffset(this, (offset, isScrolling) => {\n          this.scrollAdjustments = 0\n          this.scrollDirection = isScrolling\n            ? this.getScrollOffset() < offset\n              ? 'forward'\n              : 'backward'\n            : null\n          this.scrollOffset = offset\n\n          const prevIsScrolling = this.isScrolling\n          this.isScrolling = isScrolling\n\n          this.notify(prevIsScrolling !== isScrolling, isScrolling)\n        }),\n      )\n    }\n  }\n\n  private getSize = () => {\n    if (!this.options.enabled) {\n      this.scrollRect = null\n      return 0\n    }\n\n    this.scrollRect = this.scrollRect ?? this.options.initialRect\n\n    return this.scrollRect[this.options.horizontal ? 'width' : 'height']\n  }\n\n  private getScrollOffset = () => {\n    if (!this.options.enabled) {\n      this.scrollOffset = null\n      return 0\n    }\n\n    this.scrollOffset =\n      this.scrollOffset ??\n      (typeof this.options.initialOffset === 'function'\n        ? this.options.initialOffset()\n        : this.options.initialOffset)\n\n    return this.scrollOffset\n  }\n\n  private getFurthestMeasurement = (\n    measurements: Array<VirtualItem<TItemElement>>,\n    index: number,\n  ) => {\n    const furthestMeasurementsFound = new Map<number, true>()\n    const furthestMeasurements = new Map<number, VirtualItem<TItemElement>>()\n    for (let m = index - 1; m >= 0; m--) {\n      const measurement = measurements[m]!\n\n      if (furthestMeasurementsFound.has(measurement.lane)) {\n        continue\n      }\n\n      const previousFurthestMeasurement = furthestMeasurements.get(\n        measurement.lane,\n      )\n      if (\n        previousFurthestMeasurement == null ||\n        measurement.end > previousFurthestMeasurement.end\n      ) {\n        furthestMeasurements.set(measurement.lane, measurement)\n      } else if (measurement.end < previousFurthestMeasurement.end) {\n        furthestMeasurementsFound.set(measurement.lane, true)\n      }\n\n      if (furthestMeasurementsFound.size === this.options.lanes) {\n        break\n      }\n    }\n\n    return furthestMeasurements.size === this.options.lanes\n      ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n          if (a.end === b.end) {\n            return a.index - b.index\n          }\n\n          return a.end - b.end\n        })[0]\n      : undefined\n  }\n\n  private getMeasurementOptions = memo(\n    () => [\n      this.options.count,\n      this.options.paddingStart,\n      this.options.scrollMargin,\n      this.options.getItemKey,\n      this.options.enabled,\n    ],\n    (count, paddingStart, scrollMargin, getItemKey, enabled) => {\n      this.pendingMeasuredCacheIndexes = []\n      return {\n        count,\n        paddingStart,\n        scrollMargin,\n        getItemKey,\n        enabled,\n      }\n    },\n    {\n      key: false,\n    },\n  )\n\n  private getMeasurements = memo(\n    () => [this.getMeasurementOptions(), this.itemSizeCache],\n    (\n      { count, paddingStart, scrollMargin, getItemKey, enabled },\n      itemSizeCache,\n    ) => {\n      if (!enabled) {\n        this.measurementsCache = []\n        this.itemSizeCache.clear()\n        return []\n      }\n\n      if (this.measurementsCache.length === 0) {\n        this.measurementsCache = this.options.initialMeasurementsCache\n        this.measurementsCache.forEach((item) => {\n          this.itemSizeCache.set(item.key, item.size)\n        })\n      }\n\n      const min =\n        this.pendingMeasuredCacheIndexes.length > 0\n          ? Math.min(...this.pendingMeasuredCacheIndexes)\n          : 0\n      this.pendingMeasuredCacheIndexes = []\n\n      const measurements = this.measurementsCache.slice(0, min)\n\n      for (let i = min; i < count; i++) {\n        let measureElement = this.measurementsCache[i]?.measureElement\n\n        if (!measureElement) {\n          measureElement = (node: TItemElement | null | undefined) => {\n            const key = getItemKey(i)\n            const prevNode = this.elementsCache.get(key)\n\n            if (!node) {\n              if (prevNode) {\n                this.observer.unobserve(prevNode)\n                this.elementsCache.delete(key)\n              }\n              return\n            }\n\n            if (prevNode !== node) {\n              if (prevNode) {\n                this.observer.unobserve(prevNode)\n              }\n              this.observer.observe(node)\n              this.elementsCache.set(key, node)\n            }\n\n            if (node.isConnected) {\n              this.resizeItem(\n                i,\n                this.options.measureElement(node, undefined, this),\n              )\n            }\n          }\n        }\n\n        const key = getItemKey(i)\n\n        const furthestMeasurement =\n          this.options.lanes === 1\n            ? measurements[i - 1]\n            : this.getFurthestMeasurement(measurements, i)\n\n        const start = furthestMeasurement\n          ? furthestMeasurement.end + this.options.gap\n          : paddingStart + scrollMargin\n\n        const measuredSize = itemSizeCache.get(key)\n        const size =\n          typeof measuredSize === 'number'\n            ? measuredSize\n            : this.options.estimateSize(i)\n\n        const end = start + size\n\n        const lane = furthestMeasurement\n          ? furthestMeasurement.lane\n          : i % this.options.lanes\n\n        measurements[i] = {\n          index: i,\n          start,\n          size,\n          end,\n          key,\n          lane,\n          measureElement,\n        }\n      }\n\n      this.measurementsCache = measurements\n\n      return measurements\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getMeasurements',\n      debug: () => this.options.debug,\n    },\n  )\n\n  calculateRange = memo(\n    () => [this.getMeasurements(), this.getSize(), this.getScrollOffset()],\n    (measurements, outerSize, scrollOffset) => {\n      return (this.range =\n        measurements.length > 0 && outerSize > 0\n          ? calculateRange({\n              measurements,\n              outerSize,\n              scrollOffset,\n            })\n          : null)\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'calculateRange',\n      debug: () => this.options.debug,\n    },\n  )\n\n  private getIndexes = memo(\n    () => [\n      this.options.rangeExtractor,\n      this.calculateRange(),\n      this.options.overscan,\n      this.options.count,\n    ],\n    (rangeExtractor, range, overscan, count) => {\n      return range === null\n        ? []\n        : rangeExtractor({\n            startIndex: range.startIndex,\n            endIndex: range.endIndex,\n            overscan,\n            count,\n          })\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n      debug: () => this.options.debug,\n    },\n  )\n\n  indexFromElement = (node: TItemElement) => {\n    const attributeName = this.options.indexAttribute\n    const indexStr = node.getAttribute(attributeName)\n\n    if (!indexStr) {\n      console.warn(\n        `Missing attribute name '${attributeName}={index}' on measured element.`,\n      )\n      return -1\n    }\n\n    return parseInt(indexStr, 10)\n  }\n\n  private _measureElement = (\n    node: TItemElement,\n    entry: ResizeObserverEntry | undefined,\n  ) => {\n    const i = this.indexFromElement(node)\n    const item = this.getMeasurements()[i]\n\n    if (!item || !node.isConnected) {\n      this.elementsCache.forEach((cached, key) => {\n        if (cached === node) {\n          this.observer.unobserve(node)\n          this.elementsCache.delete(key)\n        }\n      })\n      return\n    }\n\n    const prevNode = this.elementsCache.get(item.key)\n\n    if (prevNode !== node) {\n      if (prevNode) {\n        this.observer.unobserve(prevNode)\n      }\n      this.observer.observe(node)\n      this.elementsCache.set(item.key, node)\n    }\n\n    this.resizeItem(i, this.options.measureElement(node, entry, this))\n  }\n\n  resizeItem = (index: number, size: number) => {\n    const item = this.getMeasurements()[index]\n    if (!item) {\n      return\n    }\n    const itemSize = this.itemSizeCache.get(item.key) ?? item.size\n    const delta = size - itemSize\n\n    if (delta !== 0) {\n      if (\n        this.shouldAdjustScrollPositionOnItemSizeChange !== undefined\n          ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this)\n          : item.start < this.getScrollOffset() + this.scrollAdjustments\n      ) {\n        if (process.env.NODE_ENV !== 'production' && this.options.debug) {\n          console.info('correction', delta)\n        }\n\n        this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: (this.scrollAdjustments += delta),\n          behavior: undefined,\n        })\n      }\n\n      this.pendingMeasuredCacheIndexes.push(item.index)\n      this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size))\n\n      this.notify(true, false)\n    }\n  }\n\n  measureElement = (node: TItemElement | null | undefined) => {\n    if (!node) {\n      return\n    }\n\n    this._measureElement(node, undefined)\n  }\n\n  getVirtualItems = memo(\n    () => [this.getIndexes(), this.getMeasurements()],\n    (indexes, measurements) => {\n      const virtualItems: Array<VirtualItem<TItemElement>> = []\n\n      for (let k = 0, len = indexes.length; k < len; k++) {\n        const i = indexes[k]!\n        const measurement = measurements[i]!\n\n        virtualItems.push(measurement)\n      }\n\n      return virtualItems\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n      debug: () => this.options.debug,\n    },\n  )\n\n  getVirtualItemForOffset = (offset: number) => {\n    const measurements = this.getMeasurements()\n    if (measurements.length === 0) {\n      return undefined\n    }\n    return notUndefined(\n      measurements[\n        findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index: number) => notUndefined(measurements[index]).start,\n          offset,\n        )\n      ],\n    )\n  }\n\n  getOffsetForAlignment = (toOffset: number, align: ScrollAlignment) => {\n    const size = this.getSize()\n    const scrollOffset = this.getScrollOffset()\n\n    if (align === 'auto') {\n      if (toOffset <= scrollOffset) {\n        align = 'start'\n      } else if (toOffset >= scrollOffset + size) {\n        align = 'end'\n      } else {\n        align = 'start'\n      }\n    }\n\n    if (align === 'start') {\n      toOffset = toOffset\n    } else if (align === 'end') {\n      toOffset = toOffset - size\n    } else if (align === 'center') {\n      toOffset = toOffset - size / 2\n    }\n\n    const scrollSizeProp = this.options.horizontal\n      ? 'scrollWidth'\n      : 'scrollHeight'\n    const scrollSize = this.scrollElement\n      ? 'document' in this.scrollElement\n        ? this.scrollElement.document.documentElement[scrollSizeProp]\n        : this.scrollElement[scrollSizeProp]\n      : 0\n\n    const maxOffset = scrollSize - size\n\n    return Math.max(Math.min(maxOffset, toOffset), 0)\n  }\n\n  getOffsetForIndex = (index: number, align: ScrollAlignment = 'auto') => {\n    index = Math.max(0, Math.min(index, this.options.count - 1))\n\n    const item = this.getMeasurements()[index]\n    if (!item) {\n      return undefined\n    }\n\n    const size = this.getSize()\n    const scrollOffset = this.getScrollOffset()\n\n    if (align === 'auto') {\n      if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {\n        align = 'end'\n      } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n        align = 'start'\n      } else {\n        return [scrollOffset, align] as const\n      }\n    }\n\n    const toOffset =\n      align === 'end'\n        ? item.end + this.options.scrollPaddingEnd\n        : item.start - this.options.scrollPaddingStart\n\n    return [this.getOffsetForAlignment(toOffset, align), align] as const\n  }\n\n  private isDynamicMode = () => this.elementsCache.size > 0\n\n  private cancelScrollToIndex = () => {\n    if (this.scrollToIndexTimeoutId !== null && this.targetWindow) {\n      this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId)\n      this.scrollToIndexTimeoutId = null\n    }\n  }\n\n  scrollToOffset = (\n    toOffset: number,\n    { align = 'start', behavior }: ScrollToOffsetOptions = {},\n  ) => {\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n      adjustments: undefined,\n      behavior,\n    })\n  }\n\n  scrollToIndex = (\n    index: number,\n    { align: initialAlign = 'auto', behavior }: ScrollToIndexOptions = {},\n  ) => {\n    index = Math.max(0, Math.min(index, this.options.count - 1))\n\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    const offsetAndAlign = this.getOffsetForIndex(index, initialAlign)\n    if (!offsetAndAlign) return\n\n    const [offset, align] = offsetAndAlign\n\n    this._scrollToOffset(offset, { adjustments: undefined, behavior })\n\n    if (behavior !== 'smooth' && this.isDynamicMode() && this.targetWindow) {\n      this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {\n        this.scrollToIndexTimeoutId = null\n\n        const elementInDOM = this.elementsCache.has(\n          this.options.getItemKey(index),\n        )\n\n        if (elementInDOM) {\n          const [latestOffset] = notUndefined(\n            this.getOffsetForIndex(index, align),\n          )\n\n          if (!approxEqual(latestOffset, this.getScrollOffset())) {\n            this.scrollToIndex(index, { align, behavior })\n          }\n        } else {\n          this.scrollToIndex(index, { align, behavior })\n        }\n      })\n    }\n  }\n\n  scrollBy = (delta: number, { behavior }: ScrollToOffsetOptions = {}) => {\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    this._scrollToOffset(this.getScrollOffset() + delta, {\n      adjustments: undefined,\n      behavior,\n    })\n  }\n\n  getTotalSize = () => {\n    const measurements = this.getMeasurements()\n\n    let end: number\n    // If there are no measurements, set the end to paddingStart\n    if (measurements.length === 0) {\n      end = this.options.paddingStart\n    } else {\n      // If lanes is 1, use the last measurement's end, otherwise find the maximum end value among all measurements\n      end =\n        this.options.lanes === 1\n          ? measurements[measurements.length - 1]?.end ?? 0\n          : Math.max(\n              ...measurements.slice(-this.options.lanes).map((m) => m.end),\n            )\n    }\n\n    return end - this.options.scrollMargin + this.options.paddingEnd\n  }\n\n  private _scrollToOffset = (\n    offset: number,\n    {\n      adjustments,\n      behavior,\n    }: {\n      adjustments: number | undefined\n      behavior: ScrollBehavior | undefined\n    },\n  ) => {\n    this.options.scrollToFn(offset, { behavior, adjustments }, this)\n  }\n\n  measure = () => {\n    this.itemSizeCache = new Map()\n    this.options.onChange?.(this, false)\n  }\n}\n\nconst findNearestBinarySearch = (\n  low: number,\n  high: number,\n  getCurrentValue: (i: number) => number,\n  value: number,\n) => {\n  while (low <= high) {\n    const middle = ((low + high) / 2) | 0\n    const currentValue = getCurrentValue(middle)\n\n    if (currentValue < value) {\n      low = middle + 1\n    } else if (currentValue > value) {\n      high = middle - 1\n    } else {\n      return middle\n    }\n  }\n\n  if (low > 0) {\n    return low - 1\n  } else {\n    return 0\n  }\n}\n\nfunction calculateRange<TItemElement extends Element>({\n  measurements,\n  outerSize,\n  scrollOffset,\n}: {\n  measurements: Array<VirtualItem<TItemElement>>\n  outerSize: number\n  scrollOffset: number\n}) {\n  const count = measurements.length - 1\n  const getOffset = (index: number) => measurements[index]!.start\n\n  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset)\n  let endIndex = startIndex\n\n  while (\n    endIndex < count &&\n    measurements[endIndex]!.end < scrollOffset + outerSize\n  ) {\n    endIndex++\n  }\n\n  return { startIndex, endIndex }\n}\n","import * as React from 'react'\nimport { flushSync } from 'react-dom'\nimport {\n  Virtualizer,\n  elementScroll,\n  observeElementOffset,\n  observeElementRect,\n  observeWindowOffset,\n  observeWindowRect,\n  windowScroll,\n} from '@tanstack/virtual-core'\nimport type { PartialKeys, VirtualizerOptions } from '@tanstack/virtual-core'\n\nexport * from '@tanstack/virtual-core'\n\nconst useIsomorphicLayoutEffect =\n  typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nfunction useVirtualizerBase<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n>(\n  options: VirtualizerOptions<TScrollElement, TItemElement>,\n): Virtualizer<TScrollElement, TItemElement> {\n  const rerender = React.useReducer(() => ({}), {})[1]\n\n  const resolvedOptions: VirtualizerOptions<TScrollElement, TItemElement> = {\n    ...options,\n    onChange: (instance, sync) => {\n      if (sync) {\n        flushSync(rerender)\n      } else {\n        rerender()\n      }\n      options.onChange?.(instance, sync)\n    },\n  }\n\n  const [instance] = React.useState(\n    () => new Virtualizer<TScrollElement, TItemElement>(resolvedOptions),\n  )\n\n  instance.setOptions(resolvedOptions)\n\n  React.useEffect(() => {\n    return instance._didMount()\n  }, [])\n\n  useIsomorphicLayoutEffect(() => {\n    return instance._willUpdate()\n  })\n\n  return instance\n}\n\nexport function useVirtualizer<\n  TScrollElement extends Element,\n  TItemElement extends Element,\n>(\n  options: PartialKeys<\n    VirtualizerOptions<TScrollElement, TItemElement>,\n    'observeElementRect' | 'observeElementOffset' | 'scrollToFn'\n  >,\n): Virtualizer<TScrollElement, TItemElement> {\n  return useVirtualizerBase<TScrollElement, TItemElement>({\n    observeElementRect: observeElementRect,\n    observeElementOffset: observeElementOffset,\n    scrollToFn: elementScroll,\n    ...options,\n  })\n}\n\nexport function useWindowVirtualizer<TItemElement extends Element>(\n  options: PartialKeys<\n    VirtualizerOptions<Window, TItemElement>,\n    | 'getScrollElement'\n    | 'observeElementRect'\n    | 'observeElementOffset'\n    | 'scrollToFn'\n  >,\n): Virtualizer<Window, TItemElement> {\n  return useVirtualizerBase<Window, TItemElement>({\n    getScrollElement: () => (typeof document !== 'undefined' ? window : null),\n    observeElementRect: observeWindowRect,\n    observeElementOffset: observeWindowOffset,\n    scrollToFn: windowScroll,\n    initialOffset: () => (typeof document !== 'undefined' ? window.scrollY : 0),\n    ...options,\n  })\n}\n","import { useRef, useEffect, useMemo } from 'react';\n\nexport interface CallOptions {\n  /**\n   * Controls if the function should be invoked on the leading edge of the timeout.\n   */\n  leading?: boolean;\n  /**\n   * Controls if the function should be invoked on the trailing edge of the timeout.\n   */\n  trailing?: boolean;\n}\n\nexport interface Options extends CallOptions {\n  /**\n   * The maximum time the given function is allowed to be delayed before it's invoked.\n   */\n  maxWait?: number;\n  /**\n   * If the setting is set to true, all debouncing and timers will happen on the server side as well\n   */\n  debounceOnServer?: boolean;\n}\n\nexport interface ControlFunctions<ReturnT> {\n  /**\n   * Cancel pending function invocations\n   */\n  cancel: () => void;\n  /**\n   * Immediately invoke pending function invocations\n   */\n  flush: () => ReturnT | undefined;\n  /**\n   * Returns `true` if there are any pending function invocations\n   */\n  isPending: () => boolean;\n}\n\n/**\n * Subsequent calls to the debounced function return the result of the last func invocation.\n * Note, that if there are no previous invocations you will get undefined. You should check it in your code properly.\n */\nexport interface DebouncedState<T extends (...args: any) => ReturnType<T>>\n  extends ControlFunctions<ReturnType<T>> {\n  (...args: Parameters<T>): ReturnType<T> | undefined;\n}\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked, or until the next browser frame is drawn.\n *\n * The debounced function comes with a `cancel` method to cancel delayed `func`\n * invocations and a `flush` method to immediately invoke them.\n *\n * Provide `options` to indicate whether `func` should be invoked on the leading\n * and/or trailing edge of the `wait` timeout. The `func` is invoked with the\n * last arguments provided to the debounced function.\n *\n * Subsequent calls to the debounced function return the result of the last\n * `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `debounce` and `throttle`.\n *\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0]\n *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is\n *  used (if available, otherwise it will be setTimeout(...,0)).\n * @param {Object} [options={}] The options object.\n *  Controls if `func` should be invoked on the leading edge of the timeout.\n * @param {boolean} [options.leading=false]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {number} [options.maxWait]\n *  Controls if `func` should be invoked the trailing edge of the timeout.\n * @param {boolean} [options.trailing=true]\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * const resizeHandler = useDebouncedCallback(calculateLayout, 150);\n * window.addEventListener('resize', resizeHandler)\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * const clickHandler = useDebouncedCallback(sendMail, 300, {\n *   leading: true,\n *   trailing: false,\n * })\n * <button onClick={clickHandler}>click me</button>\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * const debounced = useDebouncedCallback(batchLog, 250, { 'maxWait': 1000 })\n * const source = new EventSource('/stream')\n * source.addEventListener('message', debounced)\n *\n * // Cancel the trailing debounced invocation.\n * window.addEventListener('popstate', debounced.cancel)\n *\n * // Check for pending invocations.\n * const status = debounced.pending() ? \"Pending...\" : \"Ready\"\n */\nexport default function useDebouncedCallback<\n  T extends (...args: any) => ReturnType<T>,\n>(func: T, wait?: number, options?: Options): DebouncedState<T> {\n  const lastCallTime = useRef(null);\n  const lastInvokeTime = useRef(0);\n  const timerId = useRef(null);\n  const lastArgs = useRef<unknown[]>([]);\n  const lastThis = useRef<unknown>();\n  const result = useRef<ReturnType<T>>();\n  const funcRef = useRef(func);\n  const mounted = useRef(true);\n  // Always keep the latest version of debounce callback, with no wait time.\n  funcRef.current = func;\n\n  const isClientSide = typeof window !== 'undefined';\n  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n  const useRAF = !wait && wait !== 0 && isClientSide;\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n\n  wait = +wait || 0;\n  options = options || {};\n\n  const leading = !!options.leading;\n  const trailing = 'trailing' in options ? !!options.trailing : true; // `true` by default\n  const maxing = 'maxWait' in options;\n  const debounceOnServer =\n    'debounceOnServer' in options ? !!options.debounceOnServer : false; // `false` by default\n  const maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : null;\n\n  useEffect(() => {\n    mounted.current = true;\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n\n  // You may have a question, why we have so many code under the useMemo definition.\n  //\n  // This was made as we want to escape from useCallback hell and\n  // not to initialize a number of functions each time useDebouncedCallback is called.\n  //\n  // It means that we have less garbage for our GC calls which improves performance.\n  // Also, it makes this library smaller.\n  //\n  // And the last reason, that the code without lots of useCallback with deps is easier to read.\n  // You have only one place for that.\n  const debounced = useMemo(() => {\n    const invokeFunc = (time: number) => {\n      const args = lastArgs.current;\n      const thisArg = lastThis.current;\n\n      lastArgs.current = lastThis.current = null;\n      lastInvokeTime.current = time;\n      return (result.current = funcRef.current.apply(thisArg, args));\n    };\n\n    const startTimer = (pendingFunc: () => void, wait: number) => {\n      if (useRAF) cancelAnimationFrame(timerId.current);\n      timerId.current = useRAF\n        ? requestAnimationFrame(pendingFunc)\n        : setTimeout(pendingFunc, wait);\n    };\n\n    const shouldInvoke = (time: number) => {\n      if (!mounted.current) return false;\n\n      const timeSinceLastCall = time - lastCallTime.current;\n      const timeSinceLastInvoke = time - lastInvokeTime.current;\n\n      // Either this is the first call, activity has stopped and we're at the\n      // trailing edge, the system time has gone backwards and we're treating\n      // it as the trailing edge, or we've hit the `maxWait` limit.\n      return (\n        !lastCallTime.current ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0 ||\n        (maxing && timeSinceLastInvoke >= maxWait)\n      );\n    };\n\n    const trailingEdge = (time: number) => {\n      timerId.current = null;\n\n      // Only invoke if we have `lastArgs` which means `func` has been\n      // debounced at least once.\n      if (trailing && lastArgs.current) {\n        return invokeFunc(time);\n      }\n      lastArgs.current = lastThis.current = null;\n      return result.current;\n    };\n\n    const timerExpired = () => {\n      const time = Date.now();\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // https://github.com/xnimorz/use-debounce/issues/97\n      if (!mounted.current) {\n        return;\n      }\n      // Remaining wait calculation\n      const timeSinceLastCall = time - lastCallTime.current;\n      const timeSinceLastInvoke = time - lastInvokeTime.current;\n      const timeWaiting = wait - timeSinceLastCall;\n      const remainingWait = maxing\n        ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n        : timeWaiting;\n\n      // Restart the timer\n      startTimer(timerExpired, remainingWait);\n    };\n\n    const func: DebouncedState<T> = (...args: Parameters<T>): ReturnType<T> => {\n      if (!isClientSide && !debounceOnServer) {\n        return;\n      }\n      const time = Date.now();\n      const isInvoking = shouldInvoke(time);\n\n      lastArgs.current = args;\n      lastThis.current = this;\n      lastCallTime.current = time;\n\n      if (isInvoking) {\n        if (!timerId.current && mounted.current) {\n          // Reset any `maxWait` timer.\n          lastInvokeTime.current = lastCallTime.current;\n          // Start the timer for the trailing edge.\n          startTimer(timerExpired, wait);\n          // Invoke the leading edge.\n          return leading ? invokeFunc(lastCallTime.current) : result.current;\n        }\n        if (maxing) {\n          // Handle invocations in a tight loop.\n          startTimer(timerExpired, wait);\n          return invokeFunc(lastCallTime.current);\n        }\n      }\n      if (!timerId.current) {\n        startTimer(timerExpired, wait);\n      }\n      return result.current;\n    };\n\n    func.cancel = () => {\n      if (timerId.current) {\n        useRAF\n          ? cancelAnimationFrame(timerId.current)\n          : clearTimeout(timerId.current);\n      }\n      lastInvokeTime.current = 0;\n      lastArgs.current =\n        lastCallTime.current =\n        lastThis.current =\n        timerId.current =\n          null;\n    };\n\n    func.isPending = () => {\n      return !!timerId.current;\n    };\n\n    func.flush = () => {\n      return !timerId.current ? result.current : trailingEdge(Date.now());\n    };\n\n    return func;\n  }, [\n    leading,\n    maxing,\n    wait,\n    maxWait,\n    trailing,\n    useRAF,\n    isClientSide,\n    debounceOnServer,\n  ]);\n\n  return debounced;\n}\n","import { useCallback, useRef, useState } from 'react';\nimport useDebouncedCallback, { DebouncedState } from './useDebouncedCallback';\n\nfunction valueEquality<T>(left: T, right: T): boolean {\n  return left === right;\n}\n\nexport default function useDebounce<T>(\n  value: T,\n  delay: number,\n  options?: {\n    maxWait?: number;\n    leading?: boolean;\n    trailing?: boolean;\n    equalityFn?: (left: T, right: T) => boolean;\n  }\n): [T, DebouncedState<(value: T) => void>] {\n  const eq = (options && options.equalityFn) || valueEquality;\n\n  const activeValue = useRef(value);\n  const [, forceUpdate] = useState({});\n  const debounced = useDebouncedCallback(\n    useCallback(\n      (value: T) => {\n        activeValue.current = value;\n        forceUpdate({});\n      },\n      [forceUpdate]\n    ),\n    delay,\n    options\n  );\n  const previousValue = useRef(value);\n\n  if (!eq(previousValue.current, value)) {\n    debounced(value);\n    previousValue.current = value;\n  }\n\n  return [activeValue.current as T, debounced];\n}\n","import { difference, replaceAt } from './utils'\nimport { notifyManager } from './notifyManager'\nimport type {\n  QueryObserverOptions,\n  QueryObserverResult,\n  DefaultedQueryObserverOptions,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { NotifyOptions } from './queryObserver'\nimport { QueryObserver } from './queryObserver'\nimport { Subscribable } from './subscribable'\n\ntype QueriesObserverListener = (result: QueryObserverResult[]) => void\n\nexport class QueriesObserver extends Subscribable<QueriesObserverListener> {\n  private client: QueryClient\n  private result: QueryObserverResult[]\n  private queries: QueryObserverOptions[]\n  private observers: QueryObserver[]\n  private observersMap: Record<string, QueryObserver>\n\n  constructor(client: QueryClient, queries?: QueryObserverOptions[]) {\n    super()\n\n    this.client = client\n    this.queries = []\n    this.result = []\n    this.observers = []\n    this.observersMap = {}\n\n    if (queries) {\n      this.setQueries(queries)\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.observers.forEach((observer) => {\n        observer.subscribe((result) => {\n          this.onUpdate(observer, result)\n        })\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.size) {\n      this.destroy()\n    }\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.observers.forEach((observer) => {\n      observer.destroy()\n    })\n  }\n\n  setQueries(\n    queries: QueryObserverOptions[],\n    notifyOptions?: NotifyOptions,\n  ): void {\n    this.queries = queries\n\n    notifyManager.batch(() => {\n      const prevObservers = this.observers\n\n      const newObserverMatches = this.findMatchingObservers(this.queries)\n\n      // set options for the new observers to notify of changes\n      newObserverMatches.forEach((match) =>\n        match.observer.setOptions(match.defaultedQueryOptions, notifyOptions),\n      )\n\n      const newObservers = newObserverMatches.map((match) => match.observer)\n      const newObserversMap = Object.fromEntries(\n        newObservers.map((observer) => [observer.options.queryHash, observer]),\n      )\n      const newResult = newObservers.map((observer) =>\n        observer.getCurrentResult(),\n      )\n\n      const hasIndexChange = newObservers.some(\n        (observer, index) => observer !== prevObservers[index],\n      )\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return\n      }\n\n      this.observers = newObservers\n      this.observersMap = newObserversMap\n      this.result = newResult\n\n      if (!this.hasListeners()) {\n        return\n      }\n\n      difference(prevObservers, newObservers).forEach((observer) => {\n        observer.destroy()\n      })\n\n      difference(newObservers, prevObservers).forEach((observer) => {\n        observer.subscribe((result) => {\n          this.onUpdate(observer, result)\n        })\n      })\n\n      this.notify()\n    })\n  }\n\n  getCurrentResult(): QueryObserverResult[] {\n    return this.result\n  }\n\n  getQueries() {\n    return this.observers.map((observer) => observer.getCurrentQuery())\n  }\n\n  getObservers() {\n    return this.observers\n  }\n\n  getOptimisticResult(queries: QueryObserverOptions[]): QueryObserverResult[] {\n    return this.findMatchingObservers(queries).map((match) =>\n      match.observer.getOptimisticResult(match.defaultedQueryOptions),\n    )\n  }\n\n  private findMatchingObservers(\n    queries: QueryObserverOptions[],\n  ): QueryObserverMatch[] {\n    const prevObservers = this.observers\n    const prevObserversMap = new Map(\n      prevObservers.map((observer) => [observer.options.queryHash, observer]),\n    )\n\n    const defaultedQueryOptions = queries.map((options) =>\n      this.client.defaultQueryOptions(options),\n    )\n\n    const matchingObservers: QueryObserverMatch[] =\n      defaultedQueryOptions.flatMap((defaultedOptions) => {\n        const match = prevObserversMap.get(defaultedOptions.queryHash)\n        if (match != null) {\n          return [{ defaultedQueryOptions: defaultedOptions, observer: match }]\n        }\n        return []\n      })\n\n    const matchedQueryHashes = new Set(\n      matchingObservers.map((match) => match.defaultedQueryOptions.queryHash),\n    )\n    const unmatchedQueries = defaultedQueryOptions.filter(\n      (defaultedOptions) => !matchedQueryHashes.has(defaultedOptions.queryHash),\n    )\n\n    const matchingObserversSet = new Set(\n      matchingObservers.map((match) => match.observer),\n    )\n    const unmatchedObservers = prevObservers.filter(\n      (prevObserver) => !matchingObserversSet.has(prevObserver),\n    )\n\n    const getObserver = (options: QueryObserverOptions): QueryObserver => {\n      const defaultedOptions = this.client.defaultQueryOptions(options)\n      const currentObserver = this.observersMap[defaultedOptions.queryHash!]\n      return currentObserver ?? new QueryObserver(this.client, defaultedOptions)\n    }\n\n    const newOrReusedObservers: QueryObserverMatch[] = unmatchedQueries.map(\n      (options, index) => {\n        if (options.keepPreviousData) {\n          // return previous data from one of the observers that no longer match\n          const previouslyUsedObserver = unmatchedObservers[index]\n          if (previouslyUsedObserver !== undefined) {\n            return {\n              defaultedQueryOptions: options,\n              observer: previouslyUsedObserver,\n            }\n          }\n        }\n        return {\n          defaultedQueryOptions: options,\n          observer: getObserver(options),\n        }\n      },\n    )\n\n    const sortMatchesByOrderOfQueries = (\n      a: QueryObserverMatch,\n      b: QueryObserverMatch,\n    ): number =>\n      defaultedQueryOptions.indexOf(a.defaultedQueryOptions) -\n      defaultedQueryOptions.indexOf(b.defaultedQueryOptions)\n\n    return matchingObservers\n      .concat(newOrReusedObservers)\n      .sort(sortMatchesByOrderOfQueries)\n  }\n\n  private onUpdate(observer: QueryObserver, result: QueryObserverResult): void {\n    const index = this.observers.indexOf(observer)\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result)\n      this.notify()\n    }\n  }\n\n  private notify(): void {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({ listener }) => {\n        listener(this.result)\n      })\n    })\n  }\n}\n\ntype QueryObserverMatch = {\n  defaultedQueryOptions: DefaultedQueryObserverOptions\n  observer: QueryObserver\n}\n","import 'client-only'\nimport * as React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport type { QueryKey, QueryFunction } from '@tanstack/query-core'\nimport { notifyManager, QueriesObserver } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type { UseQueryOptions, UseQueryResult } from './types'\nimport { useIsRestoring } from './isRestoring'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport {\n  ensureStaleTime,\n  shouldSuspend,\n  fetchOptimistic,\n  willFetch,\n} from './suspense'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// - `context` is omitted as it is passed as a root-level option to `useQueries` instead.\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Omit<UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>, 'context'>\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, unknown, TData, TQueryKey>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> }\n    ? UseQueryOptionsForUseQueries<\n        TQueryFnData,\n        unknown,\n        TQueryFnData,\n        TQueryKey\n      >\n    : // Fallback\n      UseQueryOptionsForUseQueries\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? UseQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? UseQueryResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryResult<TData>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, any> }\n    ? UseQueryResult<TQueryFnData>\n    : // Fallback\n      UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryOptionsForUseQueries[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]>\n  : unknown[] extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      infer TQueryKey\n    >[]\n  ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData, TQueryKey>[]\n  : // Fallback\n    UseQueryOptionsForUseQueries[]\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryResult[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]>\n  : T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      any\n    >[]\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    UseQueryResult<unknown extends TData ? TQueryFnData : TData, TError>[]\n  : // Fallback\n    UseQueryResult[]\n\nexport function useQueries<T extends any[]>({\n  queries,\n  context,\n}: {\n  queries: readonly [...QueriesOptions<T>]\n  context?: UseQueryOptions['context']\n}): QueriesResults<T> {\n  const queryClient = useQueryClient({ context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((options) => {\n        const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, queryClient, isRestoring],\n  )\n\n  defaultedQueries.forEach((query) => {\n    ensureStaleTime(query)\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary)\n  })\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () => new QueriesObserver(queryClient, defaultedQueries),\n  )\n\n  const optimisticResult = observer.getOptimisticResult(defaultedQueries)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(defaultedQueries, { listeners: false })\n  }, [defaultedQueries, observer])\n\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) =>\n    shouldSuspend(defaultedQueries[index], result, isRestoring),\n  )\n\n  const suspensePromises = shouldAtLeastOneSuspend\n    ? optimisticResult.flatMap((result, index) => {\n        const options = defaultedQueries[index]\n        const queryObserver = observer.getObservers()[index]\n\n        if (options && queryObserver) {\n          if (shouldSuspend(options, result, isRestoring)) {\n            return fetchOptimistic(options, queryObserver, errorResetBoundary)\n          } else if (willFetch(result, isRestoring)) {\n            void fetchOptimistic(options, queryObserver, errorResetBoundary)\n          }\n        }\n        return []\n      })\n    : []\n\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises)\n  }\n  const observerQueries = observer.getQueries()\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) =>\n      getHasError({\n        result,\n        errorResetBoundary,\n        useErrorBoundary: defaultedQueries[index]?.useErrorBoundary ?? false,\n        query: observerQueries[index]!,\n      }),\n  )\n\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error\n  }\n\n  return optimisticResult as QueriesResults<T>\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useClipboard = void 0;\nvar clipboard_copy_1 = __importDefault(require(\"clipboard-copy\"));\nvar react_1 = require(\"react\");\nvar useTimedToggle_1 = require(\"./useTimedToggle\");\nfunction isInputLike(node) {\n    return node && (node.nodeName === 'TEXTAREA' || node.nodeName === 'INPUT');\n}\nfunction useClipboard(options) {\n    if (options === void 0) { options = {}; }\n    var _a = useTimedToggle_1.useTimedToggle(false), copied = _a[0], toggleCopied = _a[1];\n    var targetRef = react_1.useRef(null);\n    var optionsRef = react_1.useRef(options);\n    optionsRef.current = options;\n    function isSupported() {\n        return (!!navigator.clipboard ||\n            (typeof document.execCommand === 'function' &&\n                typeof document.queryCommandSupported === 'function' &&\n                document.queryCommandSupported('copy')));\n    }\n    var copyHandler = react_1.useCallback(function (text) {\n        var opts = optionsRef.current;\n        var target = targetRef.current;\n        function handleSuccess() {\n            if (opts.onSuccess) {\n                opts.onSuccess();\n            }\n            if (opts.copiedTimeout) {\n                toggleCopied(opts.copiedTimeout);\n            }\n            if (opts.selectOnCopy && isInputLike(target)) {\n                target.select();\n            }\n        }\n        function handleError() {\n            if (opts.onError) {\n                opts.onError();\n            }\n            if (opts.selectOnError !== false && isInputLike(target)) {\n                target.select();\n            }\n        }\n        function copy(value) {\n            clipboard_copy_1.default(value).then(handleSuccess).catch(handleError);\n        }\n        if (typeof text === 'string') {\n            copy(text);\n        }\n        else if (target) {\n            copy(target.value);\n        }\n    }, []);\n    return {\n        copied: copied,\n        copy: copyHandler,\n        isSupported: isSupported,\n        target: targetRef,\n    };\n}\nexports.useClipboard = useClipboard;\n"],"names":["memo","getDeps","fn","opts","result","deps","initialDeps","_a","_b","_c","_d","depTime","key","debug","call","Date","now","newDeps","length","some","dep","index","resultTime","depEndTime","Math","round","resultEndTime","resultFpsPercentage","pad","str","num","String","console","info","max","min","onChange","notUndefined","value","msg","Error","debounce","targetWindow","ms","timeoutId","args","clearTimeout","setTimeout","apply","this","defaultKeyExtractor","defaultRangeExtractor","range","start","startIndex","overscan","end","endIndex","count","arr","i","push","observeElementRect","instance","cb","element","scrollElement","handler","rect","width","height","getBoundingClientRect","ResizeObserver","observer","entries","entry","borderBoxSize","box","inlineSize","blockSize","observe","unobserve","addEventListenerOptions","passive","supportsScrollend","window","observeElementOffset","offset","fallback","options","isScrollingResetDelay","createHandler","isScrolling","horizontal","endHandler","addEventListener","removeEventListener","measureElement","elementScroll","adjustments","behavior","toOffset","scrollTo","Virtualizer","constructor","unsubs","scrollToIndexTimeoutId","measurementsCache","itemSizeCache","Map","pendingMeasuredCacheIndexes","scrollRect","scrollOffset","scrollDirection","scrollAdjustments","elementsCache","_ro","get","forEach","_measureElement","target","disconnect","setOptions","opts2","Object","initialOffset","paddingStart","paddingEnd","scrollPaddingStart","scrollPaddingEnd","getItemKey","rangeExtractor","initialRect","scrollMargin","gap","indexAttribute","initialMeasurementsCache","lanes","enabled","notify","force","sync","calculateRange","cleanup","filter","Boolean","d","clear","_didMount","_willUpdate","getScrollElement","ownerDocument","defaultView","_scrollToOffset","getScrollOffset","prevIsScrolling","getSize","getFurthestMeasurement","measurements","furthestMeasurementsFound","furthestMeasurements","m","measurement","has","lane","previousFurthestMeasurement","set","size","Array","from","values","sort","a","b","getMeasurementOptions","getMeasurements","item","slice","measureElement2","node","key2","prevNode","isConnected","resizeItem","delete","furthestMeasurement","measuredSize","estimateSize","process","outerSize","getOffset","findNearestBinarySearch","getIndexes","indexFromElement","attributeName","indexStr","getAttribute","parseInt","warn","cached","delta","shouldAdjustScrollPositionOnItemSizeChange","getVirtualItems","indexes","virtualItems","k","len","getVirtualItemForOffset","getOffsetForAlignment","align","scrollSizeProp","maxOffset","document","documentElement","getOffsetForIndex","isDynamicMode","cancelScrollToIndex","scrollToOffset","scrollToIndex","initialAlign","offsetAndAlign","latestOffset","abs","approxEqual","scrollBy","getTotalSize","map","scrollToFn","measure","low","high","getCurrentValue","middle","currentValue","useIsomorphicLayoutEffect","React","useVirtualizerBase","rerender","resolvedOptions","instance2","flushSync","useVirtualizer","c","e","u","r","o","f","l","v","g","current","p","w","TypeError","s","leading","x","trailing","h","y","debounceOnServer","F","maxWait","n","A","t","cancelAnimationFrame","requestAnimationFrame","arguments","cancel","isPending","flush","equalityFn","QueriesObserver","Subscribable","client","queries","super","observers","observersMap","setQueries","onSubscribe","listeners","subscribe","onUpdate","onUnsubscribe","destroy","Set","notifyOptions","notifyManager","batch","prevObservers","newObserverMatches","findMatchingObservers","match","defaultedQueryOptions","newObservers","newObserversMap","fromEntries","queryHash","newResult","getCurrentResult","hasIndexChange","hasListeners","difference","getQueries","getCurrentQuery","getObservers","getOptimisticResult","prevObserversMap","defaultQueryOptions","matchingObservers","flatMap","defaultedOptions","matchedQueryHashes","unmatchedQueries","matchingObserversSet","unmatchedObservers","prevObserver","getObserver","currentObserver","QueryObserver","newOrReusedObservers","keepPreviousData","previouslyUsedObserver","undefined","concat","sortMatchesByOrderOfQueries","indexOf","replaceAt","listener","useQueries","context","queryClient","useQueryClient","isRestoring","useIsRestoring","errorResetBoundary","useQueryErrorResetBoundary","defaultedQueries","_optimisticResults","query","ensureStaleTime","ensurePreventErrorBoundaryRetry","useClearResetErrorBoundary","optimisticResult","useSyncExternalStore","onStoreChange","batchCalls","suspensePromises","shouldSuspend","queryObserver","fetchOptimistic","willFetch","Promise","all","observerQueries","firstSingleResultWhichShouldThrow","find","_defaultedQueries$ind","_defaultedQueries$ind2","getHasError","useErrorBoundary","error","__importDefault","mod","__esModule","defineProperty","exports","useClipboard","clipboard_copy_1","require","react_1","useTimedToggle_1","isInputLike","nodeName","useTimedToggle","copied","toggleCopied","targetRef","useRef","optionsRef","copy","useCallback","text","handleSuccess","onSuccess","copiedTimeout","selectOnCopy","select","handleError","onError","selectOnError","default","then","catch","isSupported","navigator","clipboard","execCommand","queryCommandSupported"],"sourceRoot":""}